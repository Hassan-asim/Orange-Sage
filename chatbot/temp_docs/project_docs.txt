

# File: C:\Users\user\Desktop\Orange-Sage\DEPLOYMENT_GUIDE.md
# üöÄ Orange Sage - Google Cloud Run Deployment Guide

This guide will help you deploy the Orange Sage application to Google Cloud Run using GitHub Actions.

## üìã Prerequisites

1. **Google Cloud Project**
   - Project ID: `orangesage`
   - Project Number: `117299588539`
   - Region: `us-central1`

2. **Required APIs** (Enable these in Google Cloud Console)
   ```bash
   gcloud services enable cloudrun.googleapis.com
   gcloud services enable artifactregistry.googleapis.com
   gcloud services enable cloudbuild.googleapis.com
   gcloud services enable secretmanager.googleapis.com
   ```

3. **Service Account** (Create with these roles)
   - Cloud Run Admin
   - Storage Admin
   - Artifact Registry Administrator
   - Service Account User

## üîß Setup Steps

### Step 1: Create Artifact Registry Repository

```bash
gcloud artifacts repositories create orange-sage \
  --repository-format=docker \
  --location=us-central1 \
  --description="Orange Sage Docker images"
```

### Step 2: Create Service Account

```bash
# Create service account
gcloud iam service-accounts create orange-sage-deployer \
  --display-name="Orange Sage Deployer"

# Get service account email
export SA_EMAIL=$(gcloud iam service-accounts list \
  --filter="displayName:Orange Sage Deployer" \
  --format='value(email)')

# Grant necessary roles
gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:$SA_EMAIL" \
  --role="roles/run.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:$SA_EMAIL" \
  --role="roles/storage.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:$SA_EMAIL" \
  --role="roles/artifactregistry.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:$SA_EMAIL" \
  --role="roles/iam.serviceAccountUser"

# Create and download key
gcloud iam service-accounts keys create key.json \
  --iam-account=$SA_EMAIL
```

### Step 3: Configure GitHub Secrets

Add these secrets to your GitHub repository (`Settings` ‚Üí `Secrets and variables` ‚Üí `Actions`):

#### Required Secrets:

1. **GCP_SA_KEY**
   - Content: Copy the entire content of `key.json`
   - This authenticates GitHub Actions with Google Cloud

2. **GCP_SERVICE_ACCOUNT_EMAIL**
   - Content: The service account email (from Step 2)
   - Example: `orange-sage-deployer@orangesage.iam.gserviceaccount.com`

3. **SECRET_KEY**
   - Content: A random secret key for JWT tokens
   - Generate with: `openssl rand -hex 32`
   - Example: `09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7`

4. **DATABASE_URL**
   - Content: Your database connection string
   - For SQLite (development): `sqlite:///./orange_sage.db`
   - For PostgreSQL (production): `postgresql://user:password@host:port/database`

5. **BACKEND_URL**
   - Content: Your backend URL (will be updated after first deployment)
   - Initial: `https://orange-sage-backend-<hash>.a.run.app`
   - You'll get this after first backend deployment

### Step 4: Update Backend CORS Settings

After deploying the backend, update `backend/app/core/config.py`:

```python
ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://localhost:8000",
    "https://orange-sage-frontend-<your-hash>.a.run.app",  # Add your frontend URL
]
```

## üì¶ Deployment Process

### Automatic Deployment

The application will automatically deploy when you push to the `main` branch:

- **Backend**: Triggers on changes to `backend/**`
- **Frontend**: Triggers on changes to `frontend/**`

### Manual Deployment

You can also trigger deployment manually from GitHub Actions:

1. Go to `Actions` tab in your repository
2. Select `Deploy Backend to Cloud Run` or `Deploy Frontend to Cloud Run`
3. Click `Run workflow`
4. Select the `main` branch
5. Click `Run workflow`

## üîç Verification

### Check Deployment Status

1. **GitHub Actions**
   - Go to `Actions` tab
   - View workflow runs and logs

2. **Google Cloud Console**
   ```bash
   # List Cloud Run services
   gcloud run services list --region=us-central1
   
   # Get backend URL
   gcloud run services describe orange-sage-backend \
     --region=us-central1 \
     --format='value(status.url)'
   
   # Get frontend URL
   gcloud run services describe orange-sage-frontend \
     --region=us-central1 \
     --format='value(status.url)'
   ```

3. **Test Endpoints**
   ```bash
   # Test backend health
   curl https://orange-sage-backend-<hash>.a.run.app/api/v1/health
   
   # Test frontend
   curl https://orange-sage-frontend-<hash>.a.run.app
   ```

## üêõ Troubleshooting

### View Logs

```bash
# Backend logs
gcloud run services logs read orange-sage-backend \
  --region=us-central1 \
  --limit=50

# Frontend logs
gcloud run services logs read orange-sage-frontend \
  --region=us-central1 \
  --limit=50
```

### Common Issues

1. **Authentication Errors**
   - Verify `GCP_SA_KEY` is correct in GitHub Secrets
   - Check service account has necessary permissions

2. **Build Failures**
   - Check Dockerfile syntax
   - Verify dependencies in requirements.txt / package.json

3. **CORS Errors**
   - Update ALLOWED_ORIGINS in backend config
   - Redeploy backend after updating

4. **Database Connection**
   - Verify DATABASE_URL secret is correct
   - For Cloud SQL, ensure Cloud SQL Admin API is enabled

## üìä Monitoring

### Cloud Run Metrics

View metrics in Google Cloud Console:
- Request count
- Request latency
- Container instance count
- Memory and CPU usage

### Set Up Alerts

```bash
# Create alert policy for high error rate
gcloud alpha monitoring policies create \
  --notification-channels=<CHANNEL_ID> \
  --display-name="High Error Rate" \
  --condition-display-name="Error rate > 5%" \
  --condition-threshold-value=0.05 \
  --condition-threshold-duration=300s
```

## üîí Security Best Practices

1. **Environment Variables**
   - Never commit secrets to Git
   - Use GitHub Secrets for sensitive data
   - Use Google Secret Manager for production secrets

2. **Service Accounts**
   - Use least-privilege principle
   - Rotate keys regularly
   - Use Workload Identity when possible

3. **Network Security**
   - Enable Cloud Armor for DDoS protection
   - Use VPC connectors for private resources
   - Implement rate limiting

## üí∞ Cost Optimization

1. **Set Instance Limits**
   - Min instances: 0 (scales to zero)
   - Max instances: 10 (adjust based on traffic)

2. **Resource Allocation**
   - CPU: 1 vCPU
   - Memory: 512Mi
   - Timeout: 300s

3. **Monitor Costs**
   ```bash
   # View billing
   gcloud billing accounts list
   gcloud billing projects describe orangesage
   ```

## üîÑ CI/CD Pipeline

### Workflow Overview

1. **Code Push** ‚Üí GitHub detects changes
2. **Build** ‚Üí Docker image is built
3. **Push** ‚Üí Image pushed to Artifact Registry
4. **Deploy** ‚Üí Cloud Run service is updated
5. **Test** ‚Üí Health check performed
6. **Notify** ‚Üí Deployment status reported

### Customize Workflows

Edit `.github/workflows/deploy-backend.yml` or `.github/workflows/deploy-frontend.yml` to:
- Add tests before deployment
- Configure notifications (Slack, email)
- Add staging environment
- Implement blue-green deployment

## üìö Additional Resources

- [Cloud Run Documentation](https://cloud.google.com/run/docs)
- [GitHub Actions Documentation](https://docs.github.com/actions)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Next.js Deployment](https://nextjs.org/docs/deployment)
- [FastAPI Deployment](https://fastapi.tiangolo.com/deployment/)

## üÜò Support

If you encounter issues:
1. Check GitHub Actions logs
2. Check Cloud Run logs
3. Verify all secrets are configured
4. Review this deployment guide
5. Contact the development team

---

**Project:** Orange Sage Security Platform  
**Cloud Provider:** Google Cloud Platform  
**Region:** us-central1  
**Last Updated:** $(date)



# File: C:\Users\user\Desktop\Orange-Sage\QUICK_START_DEPLOYMENT.md
# üöÄ Quick Start - Deploy Orange Sage to Google Cloud Run

## ‚úÖ What's Already Done

All deployment configuration is ready:
- ‚úÖ Dockerfiles for backend and frontend
- ‚úÖ GitHub Actions CI/CD workflows
- ‚úÖ Docker ignore files
- ‚úÖ Next.js production configuration
- ‚úÖ Comprehensive deployment guide

## üìã Quick Setup (5 Steps)

### Step 1: Run Google Cloud Setup Script

On Linux/Mac:
```bash
chmod +x setup-gcloud.sh
./setup-gcloud.sh
```

On Windows (PowerShell - use Git Bash or WSL):
```bash
bash setup-gcloud.sh
```

**Or manually run these commands:**
```bash
# Set project
gcloud config set project orangesage

# Enable APIs
gcloud services enable cloudrun.googleapis.com
gcloud services enable artifactregistry.googleapis.com
gcloud services enable cloudbuild.googleapis.com

# Create Artifact Registry
gcloud artifacts repositories create orange-sage \
  --repository-format=docker \
  --location=us-central1 \
  --description="Orange Sage Docker images"

# Create Service Account
gcloud iam service-accounts create orange-sage-deployer \
  --display-name="Orange Sage Deployer"

# Get service account email
gcloud iam service-accounts list

# Grant roles (replace <SA_EMAIL> with your service account email)
gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:<SA_EMAIL>" \
  --role="roles/run.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:<SA_EMAIL>" \
  --role="roles/storage.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:<SA_EMAIL>" \
  --role="roles/artifactregistry.admin"

gcloud projects add-iam-policy-binding orangesage \
  --member="serviceAccount:<SA_EMAIL>" \
  --role="roles/iam.serviceAccountUser"

# Create key
gcloud iam service-accounts keys create gcp-key.json \
  --iam-account=<SA_EMAIL>
```

### Step 2: Configure GitHub Secrets

Go to: `https://github.com/Hassan-asim/Orange-Sage/settings/secrets/actions`

Click **"New repository secret"** for each:

1. **GCP_SA_KEY**
   ```bash
   # Copy the entire content of gcp-key.json
   cat gcp-key.json
   ```

2. **GCP_SERVICE_ACCOUNT_EMAIL**
   ```
   orange-sage-deployer@orangesage.iam.gserviceaccount.com
   ```

3. **SECRET_KEY**
   ```bash
   # Generate a random key
   openssl rand -hex 32
   ```

4. **DATABASE_URL**
   ```
   sqlite:///./orange_sage.db
   ```

5. **BACKEND_URL** (temporary - will update after deployment)
   ```
   http://localhost:8000
   ```

### Step 3: Trigger Deployment

Option A - Push to trigger automatic deployment:
```bash
# Make a small change to trigger deployment
git commit --allow-empty -m "Trigger deployment"
git push origin main
```

Option B - Manual trigger from GitHub:
1. Go to https://github.com/Hassan-asim/Orange-Sage/actions
2. Click "Deploy Backend to Cloud Run"
3. Click "Run workflow" ‚Üí Select "main" ‚Üí "Run workflow"
4. Wait for backend to deploy (~3-5 minutes)
5. Then deploy frontend the same way

### Step 4: Get Backend URL & Update Secrets

After backend deploys successfully:
```bash
# Get backend URL
gcloud run services describe orange-sage-backend \
  --region=us-central1 \
  --format='value(status.url)'

# Example output: https://orange-sage-backend-abc123-uc.a.run.app
```

**Update GitHub Secret:**
1. Go to repository secrets
2. Edit **BACKEND_URL**
3. Set value to the backend URL from above

### Step 5: Update CORS & Redeploy

Edit `backend/app/core/config.py` and add your frontend URL:

```python
ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://localhost:8000",
    "https://orange-sage-frontend-abc123-uc.a.run.app",  # Add this
]
```

Commit and push:
```bash
git add backend/app/core/config.py
git commit -m "Update CORS for production frontend"
git push origin main
```

## üéØ Access Your Deployed App

Get your URLs:
```bash
# Backend
gcloud run services describe orange-sage-backend \
  --region=us-central1 \
  --format='value(status.url)'

# Frontend
gcloud run services describe orange-sage-frontend \
  --region=us-central1 \
  --format='value(status.url)'
```

Visit your frontend URL and test:
- Login with: `user@gmail.com` / `12345678`
- Create projects, run scans, generate reports

## üìä Monitor Deployment

### GitHub Actions
- https://github.com/Hassan-asim/Orange-Sage/actions

### Cloud Run Console
- https://console.cloud.google.com/run?project=orangesage

### View Logs
```bash
# Backend logs
gcloud run services logs read orange-sage-backend \
  --region=us-central1 \
  --limit=50

# Frontend logs  
gcloud run services logs read orange-sage-frontend \
  --region=us-central1 \
  --limit=50
```

## üêõ Troubleshooting

### "Permission Denied" errors
- Verify service account has correct roles
- Check GCP_SA_KEY secret is properly formatted

### Build fails
- Check Dockerfile syntax
- Verify all dependencies are listed

### CORS errors
- Update ALLOWED_ORIGINS in backend/app/core/config.py
- Redeploy backend

### Can't access deployed app
- Check if service is allowing unauthenticated access:
  ```bash
  gcloud run services add-iam-policy-binding orange-sage-backend \
    --region=us-central1 \
    --member="allUsers" \
    --role="roles/run.invoker"
  ```

## üí∞ Expected Costs

With default configuration (512Mi RAM, 1 CPU, scales to 0):
- **Free tier**: 2 million requests/month
- **After free tier**: ~$0.00002400 per request
- **Estimated cost**: $5-20/month for moderate traffic

## üîí Security Checklist

- ‚úÖ Never commit `gcp-key.json` to Git
- ‚úÖ Use GitHub Secrets for sensitive data
- ‚úÖ Keep `SECRET_KEY` secret
- ‚úÖ Enable Cloud Armor for DDoS protection
- ‚úÖ Rotate service account keys regularly
- ‚úÖ Monitor Cloud Run logs for suspicious activity

## üìö Next Steps

1. Set up custom domain (optional)
2. Configure Cloud CDN (optional)
3. Set up monitoring & alerts
4. Configure Cloud SQL for production database
5. Implement CI/CD for staging environment

---

**Need Help?** Check the detailed [DEPLOYMENT_GUIDE.md](./DEPLOYMENT_GUIDE.md)

**Project:** Orange Sage Security Platform  
**Repository:** https://github.com/Hassan-asim/Orange-Sage  
**Cloud Project:** orangesage (117299588539)



# File: C:\Users\user\Desktop\Orange-Sage\README.md
# Orange Sage - AI-Powered Cybersecurity Assessment Platform

Orange Sage is a comprehensive web-based cybersecurity assessment platform that leverages AI agents to perform autonomous security testing. it provides a modern web interface for managing security assessments, viewing findings, and generating reports.

## üöÄ Quick Start

### Prerequisites

- **Docker Desktop** - For running required services
- **Python 3.11+** - For backend development
- **Node.js 18+** - For frontend development
- **Git** - For version control

### 1. Clone and Setup

```bash
git clone <repository-url>
cd Orange_sage
```

### 2. Start the Application

```bash
# Start everything (recommended)
python start.py
```

This will:
- Start PostgreSQL, Redis, and MinIO services
- Start the backend API server
- Start the frontend development server
- Open the application at http://localhost:5173

### 3. Alternative Manual Setup

If you prefer to start components separately:

```bash
# Start services
docker-compose up -d

# Start backend (in one terminal)
cd backend
python start.py

# Start frontend (in another terminal)
cd frontend
python start.py
```

## üèóÔ∏è Architecture

### Backend (FastAPI)
- **Framework**: FastAPI with Uvicorn
- **Database**: PostgreSQL with SQLAlchemy
- **Task Queue**: Celery with Redis
- **LLM Integration**: LiteLLM (OpenAI, Gemini)
- **Object Storage**: MinIO/S3
- **Authentication**: JWT tokens

### Frontend (React)
- **Framework**: React 18 with TypeScript
- **Build Tool**: Vite
- **UI Library**: shadcn/ui with Tailwind CSS
- **State Management**: React Query
- **Routing**: React Router

### Services
- **PostgreSQL**: Primary database
- **Redis**: Task queue and caching
- **MinIO**: Object storage for reports and artifacts

## üìÅ Project Structure

```
Orange_sage/
‚îú‚îÄ‚îÄ backend/                 # FastAPI backend
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/           # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/          # Core configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/        # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/       # Pydantic schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/      # Business logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/         # Utilities
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt   # Python dependencies
‚îÇ   ‚îî‚îÄ‚îÄ start.py          # Backend startup script
‚îú‚îÄ‚îÄ frontend/              # React frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/    # UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/        # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/        # Custom hooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/     # API services
‚îÇ   ‚îú‚îÄ‚îÄ package.json      # Node dependencies
‚îÇ   ‚îî‚îÄ‚îÄ start.py         # Frontend startup script
‚îú‚îÄ‚îÄ docker-compose.yml     # Service definitions
‚îî‚îÄ‚îÄ start.py              # Main startup script
```

## üîß Configuration

### Backend Configuration

Create `backend/.env` based on `backend/env.example`:

```env
# API Keys (Required)
OPENAI_API_KEY=sk-your-openai-key-here
GEMINI_API_KEY=AIzaSyC-your-gemini-key-here

# Database
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/orange_sage
ASYNC_DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/orange_sage

# Security
SECRET_KEY=your-super-secret-key-here
```

### Frontend Configuration

Create `frontend/.env` based on `frontend/env.example`:

```env
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

## üöÄ Features

### Core Features
- **User Authentication** - Secure login and registration
- **Project Management** - Organize security assessments
- **Target Management** - Add URLs, repositories, or file uploads
- **Scan Orchestration** - AI agent coordination
- **Real-time Monitoring** - Live scan progress and logs
- **Findings Management** - Vulnerability tracking and triage
- **Report Generation** - PDF, DOCX, and HTML reports
- **Settings Management** - User preferences and integrations

### AI Agent Capabilities
- **Autonomous Testing** - Self-directed security assessments
- **Multi-agent Coordination** - Specialized agents for different tasks
- **Real-time Adaptation** - Dynamic strategy adjustment
- **Comprehensive Coverage** - Black-box and white-box testing
- **Vulnerability Detection** - OWASP Top 10 and beyond

## üõ†Ô∏è Development

### Backend Development

```bash
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload
```

### Frontend Development

```bash
cd frontend
npm install
npm run dev
```

### Database Migrations

```bash
cd backend
alembic revision --autogenerate -m "Description"
alembic upgrade head
```

## üê≥ Docker Services

The application uses Docker Compose for local development:

- **PostgreSQL** (port 5432) - Database
- **Redis** (port 6379) - Task queue
- **MinIO** (ports 9000, 9001) - Object storage

## üìä API Documentation

Once the backend is running, visit:
- **Swagger UI**: http://localhost:8000/api/v1/docs
- **ReDoc**: http://localhost:8000/api/v1/redoc

## üîí Security

- **JWT Authentication** - Secure token-based auth
- **Role-based Access** - Admin, Developer, Auditor roles
- **Input Validation** - Pydantic schema validation
- **SQL Injection Protection** - SQLAlchemy ORM
- **CORS Configuration** - Controlled cross-origin requests

## üöÄ Deployment

### Production Deployment

1. **Backend**: Deploy to cloud provider (AWS, GCP, Azure)
2. **Frontend**: Deploy to static hosting (Vercel, Netlify)
3. **Database**: Use managed PostgreSQL service
4. **Storage**: Use managed S3-compatible storage
5. **Queue**: Use managed Redis service

### Environment Variables

Set the following environment variables in production:

```env
# Backend
SECRET_KEY=your-production-secret-key
DATABASE_URL=postgresql://user:pass@host:port/db
OPENAI_API_KEY=sk-your-production-key
GEMINI_API_KEY=AIzaSyC-your-production-key

# Frontend
VITE_API_BASE_URL=https://your-api-domain.com/api/v1
```

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests and linting
5. Submit a pull request

## üìÑ License

This project is licensed under the MIT License.

## üÜò Support

For support and questions:
- Create an issue on GitHub
- Check the documentation
- Review the API documentation

## üîÆ Roadmap

- [ ] Kubernetes deployment manifests
- [ ] Advanced reporting features
- [ ] Integration with CI/CD pipelines
- [ ] Mobile application
- [ ] Advanced analytics dashboard
- [ ] Custom agent development framework


# File: C:\Users\user\Desktop\Orange-Sage\SECURITY.md
# Security Guidelines for Orange Sage

## üîí Critical Security Rules

### 1. NEVER Commit Secrets
- ‚ùå **NEVER** commit `.env` files
- ‚ùå **NEVER** commit API keys
- ‚ùå **NEVER** commit passwords
- ‚ùå **NEVER** commit tokens
- ‚ùå **NEVER** commit private keys
- ‚ùå **NEVER** commit database credentials

### 2. Environment Variables
Always use environment variables for sensitive data:

```bash
# ‚úÖ GOOD - Use environment variables
export OPENAI_API_KEY="sk-your-key-here"
export GEMINI_API_KEY="AIzaSyC-your-key-here"
export SECRET_KEY="your-secret-key-here"

# ‚ùå BAD - Never hardcode in source code
OPENAI_API_KEY = "sk-your-key-here"  # DON'T DO THIS!
```

### 3. File Patterns to Avoid
The following file patterns are automatically ignored by `.gitignore`:

```
# Environment files
.env
.env.*
.env.local
.env.production
env.local
env.production

# API Keys and Secrets
*api*key*
*secret*
*password*
*token*
*credential*
*private*
*key*

# Database files
*.db
*.sqlite
*.sqlite3
database.yml
database.json

# Cloud credentials
.aws/
.azure/
.gcp/
credentials.json
service-account*.json
```

## üõ°Ô∏è Security Checklist

Before committing code, verify:

- [ ] No `.env` files are staged
- [ ] No API keys in source code
- [ ] No hardcoded passwords
- [ ] No database credentials
- [ ] No private keys or certificates
- [ ] No cloud provider credentials
- [ ] No Docker secrets
- [ ] No backup files with sensitive data

## üîç Pre-commit Security Check

Run this command before committing:

```bash
# Check for potential secrets
git diff --cached | grep -E "(api[_-]?key|secret|password|token|credential)" -i

# Check for environment files
git diff --cached --name-only | grep -E "\.env|env\." 

# Check for database files
git diff --cached --name-only | grep -E "\.db$|\.sqlite$"
```

## üö® If You Accidentally Commit Secrets

1. **Immediately** remove the sensitive data:
   ```bash
   git rm --cached .env
   git commit -m "Remove sensitive .env file"
   ```

2. **Rotate** any exposed credentials:
   - Generate new API keys
   - Change passwords
   - Regenerate tokens

3. **Force push** to remove from history:
   ```bash
   git push --force-with-lease origin main
   ```

4. **Notify** team members to pull the updated history

## üìã Environment Setup

### Backend Environment
Create `Orange_sage/backend/.env` with:

```env
# App Configuration
SECRET_KEY=your-super-secret-key-here
APP_ENV=development

# Database
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/orange_sage
ASYNC_DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/orange_sage

# API Keys (REPLACE WITH YOUR ACTUAL KEYS)
OPENAI_API_KEY=sk-your-openai-key-here
GEMINI_API_KEY=AIzaSyC-your-gemini-key-here

# CORS
BACKEND_CORS_ORIGINS=["http://localhost:5173", "http://localhost:3000"]

# Celery
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# S3/MinIO
S3_ENDPOINT=http://localhost:9000
S3_ACCESS_KEY=minioadmin
S3_SECRET_KEY=minioadmin
S3_BUCKET=orange-sage
```

### Frontend Environment
Create `Orange_sage/frontend/.env` with:

```env
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

## üîê Production Security

### Environment Variables
- Use a secure secret management system
- Rotate secrets regularly
- Use different secrets for different environments
- Monitor for secret exposure

### Database Security
- Use strong passwords
- Enable SSL/TLS connections
- Regular security updates
- Backup encryption

### API Security
- Rate limiting
- Input validation
- Authentication required
- HTTPS only

## üìû Security Incident Response

If you discover a security issue:

1. **Immediately** remove sensitive data from repository
2. **Rotate** all exposed credentials
3. **Notify** the team
4. **Document** the incident
5. **Review** security practices

## üéØ Best Practices

1. **Use environment variables** for all secrets
2. **Never commit** `.env` files
3. **Use strong, unique** passwords
4. **Rotate credentials** regularly
5. **Monitor** for secret exposure
6. **Use secret scanning** tools
7. **Review** commits before pushing
8. **Use** pre-commit hooks for security checks

## üõ†Ô∏è Security Tools

### Pre-commit Hooks
```bash
# Install pre-commit
pip install pre-commit

# Install security hooks
pre-commit install
```

### Secret Scanning
```bash
# Install truffleHog for secret scanning
pip install truffleHog

# Scan repository
truffleHog --regex --entropy=False .
```

### Git Hooks
```bash
# Add to .git/hooks/pre-commit
#!/bin/bash
# Check for secrets
if git diff --cached | grep -E "(api[_-]?key|secret|password|token)" -i; then
    echo "‚ùå Potential secrets detected in commit!"
    exit 1
fi
```

Remember: **Security is everyone's responsibility!** üõ°Ô∏è


# File: C:\Users\user\Desktop\Orange-Sage\SETUP_GUIDE.md
# Orange Sage Setup Guide

## üöÄ Quick Start

Orange Sage is a comprehensive AI-powered cybersecurity assessment platform. This guide will help you get it running.

## üìã Prerequisites

### Required Software
- **Python 3.8+** - [Download Python](https://www.python.org/downloads/)
- **Node.js 18+** - [Download Node.js](https://nodejs.org/)
- **Docker Desktop** - [Download Docker](https://www.docker.com/products/docker-desktop/)
- **Git** - [Download Git](https://git-scm.com/)

### Verify Installation
```bash
python --version    # Should show Python 3.8+
node --version      # Should show Node.js 18+
docker --version    # Should show Docker version
```

## üõ†Ô∏è Installation Steps

### 1. Clone and Navigate
```bash
git clone <your-repo-url>
cd Orange_sage
```

### 2. Start Required Services
```bash
# Start PostgreSQL, Redis, and MinIO
docker-compose up -d

# Verify services are running
docker ps
```

### 3. Setup Backend
```bash
cd backend

# Install Python dependencies
pip install -r requirements.txt

# Create environment file
cp env.example .env
# Edit .env with your API keys:
# OPENAI_API_KEY=your-openai-key-here
# GEMINI_API_KEY=your-gemini-key-here
# SECRET_KEY=your-secret-key-here

# Start backend
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

### 4. Setup Frontend (New Terminal)
```bash
cd frontend

# Install Node.js dependencies
npm install

# Create environment file
cp env.example .env
# Edit .env:
# VITE_API_BASE_URL=http://localhost:8000/api/v1

# Start frontend
npm run dev
```

## üåê Access the Application

- **Frontend**: http://localhost:5173
- **Backend API**: http://localhost:8000
- **API Documentation**: http://localhost:8000/api/v1/docs
- **MinIO Console**: http://localhost:9001 (admin/admin)

## üîß Configuration

### Environment Variables

#### Backend (.env)
```env
# API Keys (Required)
OPENAI_API_KEY=sk-your-openai-key-here
GEMINI_API_KEY=AIzaSyC-your-gemini-key-here

# Database
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/orange_sage
ASYNC_DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/orange_sage

# Security
SECRET_KEY=your-super-secret-key-here

# CORS
BACKEND_CORS_ORIGINS=["http://localhost:5173", "http://localhost:3000"]
```

#### Frontend (.env)
```env
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

## üéØ Features Available

### ü§ñ AI-Powered Pentesting
- **Automated Vulnerability Detection**
  - SQL Injection testing
  - Cross-Site Scripting (XSS) detection
  - Command injection testing
  - Path traversal detection
  - Authentication bypass testing
  - Session management analysis

### üîç Advanced Security Analysis
- **Network Security Scanning**
  - Port scanning and service enumeration
  - SSL/TLS configuration analysis
  - Security header assessment
  - Technology fingerprinting

### üìä Comprehensive Reporting
- **Professional PDF Reports**
  - Executive summaries
  - Detailed technical findings
  - Risk assessment and scoring
  - Remediation recommendations
  - Multiple output formats

### üèóÔ∏è Microservices Architecture
- **Scalable Service Design**
  - Vulnerability Scanner Service
  - Network Analyzer Service
  - Code Analyzer Service
  - Compliance Checker Service
  - Threat Intelligence Service
  - Report Generator Service

## üöÄ Usage Workflow

### 1. Create Project
- Navigate to Projects page
- Click "Create New Project"
- Enter project details

### 2. Add Target
- Go to your project
- Click "Add Target"
- Specify URL, repository, or upload files

### 3. Start Comprehensive Scan
- Click "Start Comprehensive Scan"
- Choose scan configuration
- Monitor real-time progress

### 4. Review Findings
- View detailed vulnerability analysis
- Filter by severity and type
- Review remediation recommendations

### 5. Generate Reports
- Click "Generate Report"
- Choose format (PDF/HTML)
- Download professional reports

## üîí Security Features

### Authentication & Authorization
- JWT-based authentication
- Role-based access control (Admin, Developer, Auditor)
- Secure session management

### Data Protection
- Encrypted API keys storage
- Secure database connections
- Input validation and sanitization

### Network Security
- CORS configuration
- Rate limiting
- Request validation

## üêõ Troubleshooting

### Common Issues

#### Python Not Found
```bash
# Windows
# Install Python from python.org or Microsoft Store
# Make sure to check "Add Python to PATH" during installation

# Verify installation
python --version
```

#### Node.js Not Found
```bash
# Install Node.js from nodejs.org
# Verify installation
node --version
npm --version
```

#### Docker Not Running
```bash
# Start Docker Desktop
# Verify Docker is running
docker --version
docker ps
```

#### Port Already in Use
```bash
# Check what's using the port
netstat -ano | findstr :8000
netstat -ano | findstr :5173

# Kill the process or use different ports
```

### Service Status Check
```bash
# Check Docker services
docker ps

# Check backend health
curl http://localhost:8000/api/v1/health

# Check frontend
curl http://localhost:5173
```

## üìö API Documentation

Once running, visit:
- **Swagger UI**: http://localhost:8000/api/v1/docs
- **ReDoc**: http://localhost:8000/api/v1/redoc

## üÜò Support

If you encounter issues:
1. Check the logs in the terminal
2. Verify all services are running
3. Check environment variables
4. Review the troubleshooting section
5. Create an issue on GitHub

## üéâ Success!

Once everything is running, you should see:
- ‚úÖ Backend API responding at http://localhost:8000
- ‚úÖ Frontend interface at http://localhost:5173
- ‚úÖ Database connected
- ‚úÖ All services healthy

Happy security testing! üõ°Ô∏è


# File: C:\Users\user\Desktop\Orange-Sage\SETUP_PYTHON.md
# Python Installation Guide for Orange Sage

## üêç Installing Python on Windows

### Method 1: Official Python Website (Recommended)

1. **Download Python**:
   - Go to https://www.python.org/downloads/
   - Click "Download Python 3.11.x" (latest version)
   - Choose "Windows installer (64-bit)"

2. **Install Python**:
   - Run the downloaded installer
   - ‚ö†Ô∏è **IMPORTANT**: Check "Add Python to PATH" at the bottom
   - Click "Install Now"
   - Wait for installation to complete

3. **Verify Installation**:
   - Open Command Prompt or PowerShell
   - Type: `python --version`
   - You should see: `Python 3.11.x`

### Method 2: Microsoft Store (Alternative)

1. **Open Microsoft Store**:
   - Press `Windows + R`
   - Type `ms-windows-store:` and press Enter

2. **Search for Python**:
   - Search for "Python 3.11"
   - Click "Install"

3. **Verify Installation**:
   - Open Command Prompt or PowerShell
   - Type: `python --version`

## üöÄ Running Orange Sage After Python Installation

### Step 1: Install Backend Dependencies
```bash
cd backend
pip install -r requirements_local.txt
```

### Step 2: Start Backend
```bash
cd backend
python -m uvicorn app.main_local:app --host 0.0.0.0 --port 8000 --reload
```

### Step 3: Install Frontend Dependencies (New Terminal)
```bash
cd frontend
npm install
```

### Step 4: Start Frontend (New Terminal)
```bash
cd frontend
npm run dev
```

## üåê Access the Application

- **Frontend**: http://localhost:5173
- **Backend API**: http://localhost:8000
- **API Documentation**: http://localhost:8000/api/v1/docs

## üîß Troubleshooting

### Python Not Found Error
If you get "Python was not found":

1. **Check if Python is installed**:
   - Open Command Prompt
   - Try: `python --version`
   - Try: `python3 --version` 
   - Try: `py --version`

2. **If none work, reinstall Python**:
   - Go to https://www.python.org/downloads/
   - Download Python 3.11.x
   - ‚ö†Ô∏è **CRITICAL**: Check "Add Python to PATH" at the bottom
   - Choose "Customize installation"
   - Check "Add Python to environment variables"
   - Complete installation

3. **Restart everything**:
   - Close all terminals/command prompts
   - Restart your computer (recommended)
   - Open new Command Prompt
   - Try again

4. **Test Python manually**:
   ```bash
   python test_python.py
   ```

5. **Alternative commands**:
   - Use `py` instead of `python`
   - Use `python3` instead of `python`

### Permission Errors
If you get permission errors:
```bash
# Try with --user flag
pip install --user -r requirements_local.txt
```

### Node.js Not Found
If you get Node.js errors:
1. Install Node.js from https://nodejs.org
2. Choose LTS version (18.x or higher)
3. Restart terminal after installation

## üìã Quick Checklist

- [ ] Python 3.8+ installed and working
- [ ] Node.js 18+ installed and working
- [ ] Backend dependencies installed
- [ ] Frontend dependencies installed
- [ ] Backend running on port 8000
- [ ] Frontend running on port 5173

## üéØ What's Next?

Once Python is installed and working:

1. **Test Python**: `python --version`
2. **Install Backend Dependencies**: `cd backend && pip install -r requirements_local.txt`
3. **Start Backend**: `cd backend && python -m uvicorn app.main_local:app --reload`
4. **Install Frontend Dependencies**: `cd frontend && npm install`
5. **Start Frontend**: `cd frontend && npm run dev`

Then visit http://localhost:5173 to see Orange Sage! üéâ


# File: C:\Users\user\Desktop\Orange-Sage\test_python.py
#!/usr/bin/env python3
"""
Simple Python test script to verify installation
"""
import sys
import platform

print("üêç Python Installation Test")
print("=" * 30)
print(f"Python Version: {sys.version}")
print(f"Python Executable: {sys.executable}")
print(f"Platform: {platform.platform()}")
print(f"Architecture: {platform.architecture()}")

# Test basic imports
try:
    import fastapi
    print("‚úÖ FastAPI available")
except ImportError:
    print("‚ùå FastAPI not installed")

try:
    import uvicorn
    print("‚úÖ Uvicorn available")
except ImportError:
    print("‚ùå Uvicorn not installed")

try:
    import sqlalchemy
    print("‚úÖ SQLAlchemy available")
except ImportError:
    print("‚ùå SQLAlchemy not installed")

print("\nüéâ Python is working correctly!")
print("You can now run: setup.bat")


# File: C:\Users\user\Desktop\Orange-Sage\backend\init_demo_user.py
"""
Initialize demo user for testing
"""
import asyncio
from sqlalchemy.orm import Session
from app.core.database import SessionLocal, init_db
from app.models.user import User
from app.utils.auth import get_password_hash

async def create_demo_user():
    """Create demo user with email: user@gmail.com, password: 12345678"""
    await init_db()
    
    db: Session = SessionLocal()
    try:
        # Check if demo user already exists
        existing_user = db.query(User).filter(User.email == "user@gmail.com").first()
        
        if existing_user:
            print("‚úÖ Demo user already exists")
            print(f"   Email: user@gmail.com")
            print(f"   Password: 12345678")
            return
        
        # Create demo user
        hashed_password = get_password_hash("12345678")
        demo_user = User(
            email="user@gmail.com",
            username="demo_user",
            hashed_password=hashed_password,
            full_name="Demo User",
            is_active=True
        )
        
        db.add(demo_user)
        db.commit()
        db.refresh(demo_user)
        
        print("‚úÖ Demo user created successfully!")
        print(f"   Email: user@gmail.com")
        print(f"   Password: 12345678")
        print(f"   User ID: {demo_user.id}")
        
    except Exception as e:
        print(f"‚ùå Error creating demo user: {e}")
        db.rollback()
    finally:
        db.close()

if __name__ == "__main__":
    asyncio.run(create_demo_user())



# File: C:\Users\user\Desktop\Orange-Sage\backend\README.md
# Orange Sage Backend

A comprehensive cybersecurity assessment platform with AI agents for automated security testing.

## Features

- **AI-Powered Security Assessment**: Automated vulnerability scanning using advanced AI agents
- **Multi-LLM Support**: Integration with OpenAI and Google Gemini APIs
- **Docker Sandboxing**: Secure execution environment for security testing
- **Comprehensive Reporting**: PDF, DOCX, and HTML report generation
- **RESTful API**: FastAPI-based backend with OpenAPI documentation
- **User Authentication**: JWT-based authentication system
- **Project Management**: Multi-tenant project and target management

## Architecture

### Core Components

- **Agent Manager**: Orchestrates AI agents for security assessments
- **LLM Service**: Manages interactions with OpenAI and Gemini APIs
- **Sandbox Service**: Handles Docker container management for secure execution
- **Report Generator**: Creates comprehensive security reports in multiple formats
- **Database**: SQLAlchemy ORM with PostgreSQL/SQLite support

### AI Agents

- **Orange Sage Agent**: Main security assessment agent
- **Reconnaissance Agent**: Information gathering and enumeration
- **Vulnerability Agent**: Specialized vulnerability testing
- **Custom Agents**: Extensible agent system for specific security tests

## Installation

### Prerequisites

- Python 3.11+
- Docker
- Redis (optional, for caching)
- PostgreSQL (optional, SQLite for development)

### Setup

1. **Clone and navigate to backend directory**
   ```bash
   cd Orange_sage/backend
   ```

2. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

3. **Configure environment**
   ```bash
   cp env.example .env
   # Edit .env with your configuration
   ```

4. **Initialize database**
   ```bash
   # Database tables will be created automatically on first run
   ```

5. **Run the application**
   ```bash
   uvicorn app.main:app --reload
   ```

## Configuration

### Environment Variables

Key configuration options in `.env`:

```env
# LLM Configuration
OPENAI_API_KEY=your_openai_api_key
GEMINI_API_KEY=your_gemini_api_key
DEFAULT_LLM_MODEL=gpt-4o-mini
FALLBACK_LLM_MODEL=gemini-1.5-flash

# Database
DATABASE_URL=sqlite:///./orange_sage.db

# Security
SECRET_KEY=your-secret-key
ACCESS_TOKEN_EXPIRE_MINUTES=30

# Docker/Sandbox
SANDBOX_IMAGE=orange_sage/sandbox:latest
SANDBOX_MEMORY_LIMIT=2g
SANDBOX_CPU_LIMIT=1.0
```

### API Keys

The application supports both OpenAI and Google Gemini APIs:

- **OpenAI**: Set `OPENAI_API_KEY` for GPT models
- **Gemini**: Set `GEMINI_API_KEY` for Google's Gemini models
- **Fallback**: If primary model fails, automatically falls back to secondary

## API Documentation

Once running, access the interactive API documentation at:
- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

### Key Endpoints

- `POST /api/v1/auth/register` - User registration
- `POST /api/v1/auth/login` - User authentication
- `GET /api/v1/projects` - List projects
- `POST /api/v1/scans` - Create security scan
- `GET /api/v1/scans/{scan_id}` - Get scan status
- `GET /api/v1/findings` - List security findings
- `POST /api/v1/reports/generate` - Generate report

## Security Features

### Sandboxing

- **Docker Containers**: Each agent runs in isolated Docker containers
- **Resource Limits**: CPU and memory limits for security
- **Network Isolation**: Controlled network access for agents
- **File System**: Restricted file system access

### Authentication

- **JWT Tokens**: Secure token-based authentication
- **Password Hashing**: bcrypt password hashing
- **Token Expiration**: Configurable token expiration
- **User Roles**: Role-based access control

## Development

### Project Structure

```
app/
‚îú‚îÄ‚îÄ api/           # API routes and endpoints
‚îú‚îÄ‚îÄ core/          # Core configuration and database
‚îú‚îÄ‚îÄ models/        # Database models
‚îú‚îÄ‚îÄ schemas/       # Pydantic schemas
‚îú‚îÄ‚îÄ services/      # Business logic services
‚îú‚îÄ‚îÄ tasks/         # Background tasks
‚îî‚îÄ‚îÄ utils/         # Utility functions
```

### Adding New Agents

1. Create agent class inheriting from `BaseAgent`
2. Implement `execute()` method
3. Register in `AgentFactory`
4. Add to agent configuration

### Adding New Report Formats

1. Implement format-specific generation method
2. Add format to `ReportFormat` enum
3. Update report generation logic

## Deployment

### Docker Deployment

```bash
# Build image
docker build -t orange-sage-backend .

# Run container
docker run -p 8000:8000 --env-file .env orange-sage-backend
```

### Production Considerations

- Use PostgreSQL for production database
- Configure Redis for caching
- Set up proper logging
- Configure reverse proxy (nginx)
- Use HTTPS in production
- Set up monitoring and alerting

## Monitoring

### Health Checks

- `GET /health` - Basic health check
- `GET /health/detailed` - Detailed service status

### Metrics

- Agent execution times
- LLM API usage and costs
- Database performance
- Docker container metrics

## Contributing

1. Fork the repository
2. Create feature branch
3. Make changes
4. Add tests
5. Submit pull request

## License

This project is licensed under the MIT License.


# File: C:\Users\user\Desktop\Orange-Sage\backend\requirements.txt
# FastAPI and web framework
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
python-multipart>=0.0.6

# Database
sqlalchemy>=2.0.0
alembic>=1.12.0
# Use sqlite for local development (no psycopg2 needed)

# Authentication
python-jose[cryptography]==3.3.0
passlib[argon2]==1.7.4
argon2-cffi==25.1.0
python-multipart==0.0.20

# LLM APIs
openai>=1.3.0
google-generativeai>=0.3.0

# Docker (optional for local dev)
docker>=6.1.0

# Report generation
reportlab>=4.0.0
python-docx>=1.1.0
jinja2>=3.1.0
# weasyprint>=60.0  # OPTIONAL: For HTML to PDF conversion (requires GTK+ on Windows - see docs)
# Note: WeasyPrint is commented out for Windows compatibility. 
# ReportLab is used instead. To enable WeasyPrint:
# 1. Install GTK3: https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer
# 2. Uncomment the line above and run: uv pip install --system weasyprint

# Utilities
pydantic[email]>=2.10.0
pydantic-settings>=2.7.0
python-dotenv==1.1.1
redis==6.4.0
celery==5.5.3

# Development
pytest>=7.4.0
pytest-asyncio>=0.21.0
black>=23.11.0
flake8>=6.1.0
mypy>=1.7.0

# Additional utilities
requests>=2.31.0
aiofiles>=23.2.0
aiohappyeyeballs==2.6.1
aiohttp==3.13.1
aiosignal==1.4.0
amqp==5.3.1
annotated-types==0.7.0
anyio==4.11.0
arabic-reshaper==3.0.0
argon2-cffi-bindings==25.1.0
asn1crypto==1.5.1
attrs==25.4.0
bcrypt==5.0.0
billiard==4.2.2
cachetools==6.2.1
certifi==2025.10.5
cffi==2.0.0
charset-normalizer==3.4.4
click==8.3.0
click-didyoumean==0.3.1
click-plugins==1.1.1.2
click-repl==0.3.0
colorama==0.4.6
cryptography==46.0.3
cssselect2==0.8.0
distro==1.9.0
dnspython==2.8.0
docker==7.1.0
email-validator==2.3.0
fastapi==0.119.0
freetype-py==2.5.1
frozenlist==1.8.0
google-ai-generativelanguage==0.6.15
google-api-core==2.26.0
google-api-python-client==2.185.0
google-auth==2.41.1
google-auth-httplib2==0.2.0
google-generativeai==0.8.5
googleapis-common-protos==1.70.0
greenlet==3.2.4
grpcio==1.75.1
grpcio-status==1.71.2
h11==0.16.0
html5lib==1.1
httpcore==1.0.9
httplib2==0.31.0
httpx==0.28.1
idna==3.11
jinja2==3.1.6
jiter==0.11.1
jwt==1.4.0
kombu==5.5.4
lxml==6.0.2
markupsafe==3.0.3
multidict==6.7.0
openai==2.5.0
oscrypto==1.3.0
packaging==25.0
passlib==1.7.4
pillow==12.0.0
prompt-toolkit==3.0.52
propcache==0.4.1
proto-plus==1.26.1
protobuf==5.29.5
pyasn1==0.6.1
pyasn1-modules==0.4.2
pycairo==1.28.0
pycparser==2.23
pydantic==2.12.3
pydantic-core==2.41.4
pyhanko==0.31.0
pyhanko-certvalidator==0.29.0
pyjwt==2.10.1
pyparsing==3.2.5
pypdf==6.1.1
python-bidi==0.6.6
python-dateutil==2.9.0.post0
pyyaml==6.0.3
reportlab==4.4.4
requests==2.32.5
rlpycairo==0.4.0
rsa==4.9.1
six==1.17.0
sniffio==1.3.1
sqlalchemy==2.0.44
starlette==0.48.0
svglib==1.6.0
tinycss2==1.4.0
tqdm==4.67.1
typing-extensions==4.15.0
typing-inspection==0.4.2
tzdata==2025.2
tzlocal==5.3.1
uritemplate==4.2.0
uritools==5.0.0
urllib3==2.5.0
uvicorn==0.38.0
vine==5.1.0
wcwidth==0.2.14
webencodings==0.5.1
xhtml2pdf==0.2.17
yarl==1.22.0


# File: C:\Users\user\Desktop\Orange-Sage\backend\start.py
#!/usr/bin/env python3
"""
Startup script for Orange Sage Backend
"""
import os
import sys
import subprocess
import time
import requests
from pathlib import Path

def check_service(url, name, timeout=30):
    """Check if a service is running"""
    print(f"Checking {name} at {url}...")
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                print(f"‚úÖ {name} is running")
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    print(f"‚ùå {name} is not responding after {timeout}s")
    return False

def main():
    print("üöÄ Starting Orange Sage Backend...")
    
    # Check if we're in the right directory
    if not Path("app").exists():
        print("‚ùå Please run this script from the Orange_sage/backend directory")
        sys.exit(1)
    
    # Check if .env file exists
    if not Path(".env").exists() and not Path("env.local").exists():
        print("‚ö†Ô∏è  No .env file found. Using default configuration.")
        print("   Create a .env file based on env.example for production use.")
    
    # Check database configuration
    print("\nüîç Checking database configuration...")
    
    # Check if using SQLite (local development)
    env_file = Path("env.local") if Path("env.local").exists() else Path(".env")
    if env_file.exists():
        with open(env_file, 'r') as f:
            env_content = f.read()
            if "sqlite" in env_content.lower():
                print("‚úÖ Using SQLite database (local development mode)")
                print("   No external services required for SQLite")
            else:
                print("‚ö†Ô∏è  Using external database - checking services...")
                # Check PostgreSQL
                if not check_service("http://localhost:5432", "PostgreSQL"):
                    print("   Please start PostgreSQL or run: docker-compose up -d postgres")
                    sys.exit(1)
                
                # Check Redis
                if not check_service("http://localhost:6379", "Redis"):
                    print("   Please start Redis or run: docker-compose up -d redis")
                    sys.exit(1)
                
                # Check MinIO
                if not check_service("http://localhost:9000", "MinIO"):
                    print("   Please start MinIO or run: docker-compose up -d minio")
                    sys.exit(1)
                
                print("\n‚úÖ All external services are running!")
    else:
        print("‚úÖ Using default SQLite configuration")
    
    # Start the FastAPI application
    print("\nüöÄ Starting FastAPI server...")
    try:
        subprocess.run([
            sys.executable, "-m", "uvicorn", 
            "app.main:app", 
            "--host", "0.0.0.0", 
            "--port", "8000", 
            "--reload"
        ], check=True)
    except KeyboardInterrupt:
        print("\nüëã Shutting down...")
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Error starting server: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()


# File: C:\Users\user\Desktop\Orange-Sage\backend\WINDOWS_SETUP.md
# Windows Setup Guide for Orange Sage Backend

## Overview

The Orange Sage backend is fully compatible with Windows. However, some optional features require additional setup.

## Quick Start (Windows)

1. **Install Python 3.13** (already done ‚úÖ)

2. **Install dependencies**:
   ```bash
   cd backend
   uv pip install --system -r requirements.txt
   ```

3. **Start the server**:
   ```bash
   python start.py
   ```

The server will start on `http://localhost:8000` üöÄ

## Optional Features

### 1. Docker Sandbox Mode (Optional)

**What it does**: Runs security scanning agents in isolated Docker containers for enhanced security.

**Default behavior**: Uses mock sandbox mode (perfectly fine for development and testing).

**To enable**:
1. Install [Docker Desktop for Windows](https://www.docker.com/products/docker-desktop/)
2. Start Docker Desktop
3. Restart the Orange Sage backend

**Status**: The backend works perfectly fine without Docker!

---

### 2. WeasyPrint PDF Generation (Optional)

**What it does**: Advanced HTML to PDF conversion with better styling options.

**Default behavior**: Uses ReportLab for PDF generation (fully functional).

**To enable on Windows**:
1. Download and install GTK3 runtime from: 
   https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer
2. Uncomment the `weasyprint` line in `requirements.txt`
3. Run: `uv pip install --system weasyprint`

**Alternative**: Use WSL2 (Windows Subsystem for Linux) where WeasyPrint works natively.

**Status**: ReportLab provides all the PDF functionality you need!

---

## Python 3.13 Compatibility

‚úÖ **Fixed!** The backend now uses:
- `pydantic>=2.10.0` (Python 3.13 compatible)
- `pydantic-settings>=2.7.0` (Python 3.13 compatible)

The previous version (`pydantic==2.5.0`) had build issues on Python 3.13.

---

## Troubleshooting

### "WeasyPrint not available" message
- **This is normal on Windows!** The app uses ReportLab instead.
- No action needed unless you specifically need WeasyPrint features.

### "Docker not available" message
- **This is normal if Docker Desktop isn't running!**
- The app uses mock sandbox mode which works fine for development.
- No action needed for basic usage.

### Database issues
- The backend uses SQLite by default (no setup required).
- Database file: `orange_sage.db` in the backend directory.

---

## Environment Setup

1. Copy `env.local` to `.env`:
   ```bash
   copy env.local .env
   ```

2. Update API keys in `.env`:
   ```
   OPENAI_API_KEY=your-key-here
   GEMINI_API_KEY=your-key-here
   ```

3. (Optional) Configure other settings as needed.

---

## Running the Backend

```bash
# Development mode with auto-reload
python start.py

# Or directly with uvicorn
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

---

## Need Help?

- Check logs in the console output
- Ensure Python 3.13 is installed: `python --version`
- Ensure all dependencies are installed: `uv pip list --system`

---

**Last Updated**: October 2025  
**Compatible with**: Python 3.13+, Windows 10/11



# File: C:\Users\user\Desktop\Orange-Sage\backend\app\main.py
"""
Orange Sage Backend API
A comprehensive cybersecurity assessment platform with AI agents
"""

import os
import logging
from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
import uvicorn

from app.core.config import settings
from app.core.database import init_db
from app.core.logging_config import setup_logging
from app.api.v1.api import api_router
from app.services.agent_manager import AgentManager
from app.services.report_generator import ReportGenerator

# Setup logging
setup_logging()
logger = logging.getLogger(__name__)

# Global services
agent_manager: AgentManager = None
report_generator: ReportGenerator = None


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan manager"""
    # Startup
    logger.info("üöÄ Starting Orange Sage Backend API")
    
    # Initialize database
    try:
        await init_db()
        logger.info("‚úÖ Database initialized")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Database initialization failed: {e}")
        logger.info("‚ö†Ô∏è  Continuing without database (in-memory mode)")
    
    # Initialize services
    global agent_manager, report_generator
    try:
        agent_manager = AgentManager()
        logger.info("‚úÖ Agent Manager initialized")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Agent Manager initialization failed (Docker not available): {e}")
        agent_manager = None
    
    try:
        report_generator = ReportGenerator()
        logger.info("‚úÖ Report Generator initialized")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Report Generator initialization failed: {e}")
        report_generator = None
    
    logger.info("‚úÖ Services initialized")
    logger.info("üåê Orange Sage Backend API ready")
    
    yield
    
    # Shutdown
    logger.info("üõë Shutting down Orange Sage Backend API")
    if agent_manager:
        try:
            await agent_manager.cleanup()
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")
    logger.info("‚úÖ Cleanup completed")


# Create FastAPI application
app = FastAPI(
    title="Orange Sage API",
    description="AI-powered cybersecurity assessment platform",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Add middleware - CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins for Cloud Run
    allow_credentials=False,  # Must be False when using wildcard origins
    allow_methods=["*"],
    allow_headers=["*"],
)

# TrustedHostMiddleware - only add if not using wildcard
if settings.ALLOWED_HOSTS != ["*"]:
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=settings.ALLOWED_HOSTS
    )

# Include API routes
app.include_router(api_router, prefix="/api/v1")


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "Orange Sage API",
        "version": "1.0.0",
        "status": "operational",
        "docs": "/docs"
    }


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "Orange Sage Backend API",
        "version": "1.0.0"
    }


@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    """Custom HTTP exception handler"""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.detail,
            "status_code": exc.status_code,
            "path": str(request.url)
        }
    )


@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """General exception handler"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "status_code": 500,
            "path": str(request.url)
        }
    )


if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\main_local.py
"""
Local Orange Sage Backend (without Docker dependencies)
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import os

from app.core.config_local import settings
from app.core.database_local import init_db, get_db
from app.core.logging_config import setup_logging
from app.api.v1.api import api_router

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    setup_logging()
    init_db()  # Initialize SQLite database
    print("üöÄ Orange Sage Backend started successfully!")
    print(f"üìä API Documentation: http://localhost:8000/api/v1/docs")
    print(f"üåê CORS Origins: {settings.BACKEND_CORS_ORIGINS}")
    yield
    # Shutdown
    print("üëã Orange Sage Backend shutting down...")

app = FastAPI(
    title=settings.PROJECT_NAME,
    description="AI-Powered Cybersecurity Assessment Platform",
    version="1.0.0",
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    lifespan=lifespan,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    return {
        "message": "Orange Sage API",
        "version": "1.0.0",
        "docs": "/api/v1/docs",
        "status": "running"
    }

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "database": "sqlite",
        "message": "Orange Sage is running locally"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main_local:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\agents\pentesting_agent.py
"""
Advanced Pentesting Agent for Orange Sage
Performs comprehensive security assessments with real vulnerability detection
"""

import asyncio
import json
import logging
import re
import requests
import subprocess
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, urlparse
import socket
import ssl
import hashlib
import base64

logger = logging.getLogger(__name__)


class PentestingAgent:
    """Advanced AI-powered pentesting agent"""
    
    def __init__(self, agent_id: str, target: str, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.target = target
        self.config = config
        self.findings = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Orange-Sage-Security-Scanner/1.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
        
        # Security testing payloads
        self.payloads = {
            'sql_injection': [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users --",
                "1' OR '1'='1' --",
                "admin'--",
                "' OR 1=1 --",
                "') OR ('1'='1",
                "1' OR '1'='1' /*",
                "admin' OR '1'='1' --",
                "' OR 'x'='x"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "<select onfocus=alert('XSS') autofocus>",
                "<textarea onfocus=alert('XSS') autofocus>",
                "<keygen onfocus=alert('XSS') autofocus>"
            ],
            'command_injection': [
                "; ls -la",
                "| whoami",
                "& dir",
                "; cat /etc/passwd",
                "| id",
                "; uname -a",
                "& type C:\\windows\\system32\\drivers\\etc\\hosts",
                "; ps aux",
                "| netstat -an",
                "; ifconfig"
            ],
            'path_traversal': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "..%2F..%2F..%2Fetc%2Fpasswd",
                "..%252F..%252F..%252Fetc%252Fpasswd",
                "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
                "..%c1%9c..%c1%9c..%c1%9cetc%c1%9cpasswd"
            ]
        }
    
    async def execute_pentest(self) -> Dict[str, Any]:
        """Execute comprehensive pentesting assessment"""
        try:
            logger.info(f"Starting pentest for target: {self.target}")
            
            # Parse target
            parsed_target = self._parse_target()
            if not parsed_target:
                return {"error": "Invalid target format"}
            
            # Phase 1: Reconnaissance
            await self._reconnaissance_phase(parsed_target)
            
            # Phase 2: Vulnerability Scanning
            await self._vulnerability_scanning_phase(parsed_target)
            
            # Phase 3: Exploitation Testing
            await self._exploitation_phase(parsed_target)
            
            # Phase 4: Post-exploitation Analysis
            await self._post_exploitation_phase(parsed_target)
            
            # Generate comprehensive report
            report = self._generate_report()
            
            logger.info(f"Pentest completed for {self.target}. Found {len(self.findings)} vulnerabilities")
            
            return {
                "status": "completed",
                "target": self.target,
                "findings": self.findings,
                "report": report,
                "summary": {
                    "total_findings": len(self.findings),
                    "critical": len([f for f in self.findings if f.get('severity') == 'critical']),
                    "high": len([f for f in self.findings if f.get('severity') == 'high']),
                    "medium": len([f for f in self.findings if f.get('severity') == 'medium']),
                    "low": len([f for f in self.findings if f.get('severity') == 'low'])
                }
            }
            
        except Exception as e:
            logger.error(f"Error in pentest execution: {e}")
            return {"error": str(e), "status": "failed"}
    
    def _parse_target(self) -> Optional[Dict[str, Any]]:
        """Parse target URL or hostname"""
        try:
            if self.target.startswith(('http://', 'https://')):
                parsed = urlparse(self.target)
                return {
                    'type': 'web',
                    'url': self.target,
                    'hostname': parsed.hostname,
                    'port': parsed.port or (443 if parsed.scheme == 'https' else 80),
                    'scheme': parsed.scheme,
                    'path': parsed.path
                }
            else:
                # Assume it's a hostname/IP
                return {
                    'type': 'host',
                    'hostname': self.target,
                    'port': 80
                }
        except Exception as e:
            logger.error(f"Error parsing target: {e}")
            return None
    
    async def _reconnaissance_phase(self, target: Dict[str, Any]):
        """Phase 1: Information gathering and reconnaissance"""
        logger.info("Phase 1: Reconnaissance")
        
        if target['type'] == 'web':
            await self._web_reconnaissance(target)
        else:
            await self._host_reconnaissance(target)
    
    async def _web_reconnaissance(self, target: Dict[str, Any]):
        """Web application reconnaissance"""
        try:
            # Basic HTTP response analysis
            response = await self._make_request(target['url'])
            if response:
                self._analyze_http_response(response, target)
            
            # Directory enumeration
            await self._directory_enumeration(target)
            
            # Technology fingerprinting
            await self._technology_fingerprinting(target)
            
            # SSL/TLS analysis
            if target['scheme'] == 'https':
                await self._ssl_analysis(target)
                
        except Exception as e:
            logger.error(f"Error in web reconnaissance: {e}")
    
    async def _host_reconnaissance(self, target: Dict[str, Any]):
        """Host-based reconnaissance"""
        try:
            # Port scanning
            await self._port_scanning(target)
            
            # Service enumeration
            await self._service_enumeration(target)
            
            # OS fingerprinting
            await self._os_fingerprinting(target)
            
        except Exception as e:
            logger.error(f"Error in host reconnaissance: {e}")
    
    async def _vulnerability_scanning_phase(self, target: Dict[str, Any]):
        """Phase 2: Automated vulnerability scanning"""
        logger.info("Phase 2: Vulnerability Scanning")
        
        if target['type'] == 'web':
            await self._web_vulnerability_scanning(target)
        else:
            await self._host_vulnerability_scanning(target)
    
    async def _web_vulnerability_scanning(self, target: Dict[str, Any]):
        """Web application vulnerability scanning"""
        try:
            # SQL Injection testing
            await self._test_sql_injection(target)
            
            # XSS testing
            await self._test_xss(target)
            
            # Command injection testing
            await self._test_command_injection(target)
            
            # Path traversal testing
            await self._test_path_traversal(target)
            
            # Authentication bypass testing
            await self._test_authentication_bypass(target)
            
            # Session management testing
            await self._test_session_management(target)
            
            # CSRF testing
            await self._test_csrf(target)
            
        except Exception as e:
            logger.error(f"Error in web vulnerability scanning: {e}")
    
    async def _host_vulnerability_scanning(self, target: Dict[str, Any]):
        """Host-based vulnerability scanning"""
        try:
            # Service vulnerability scanning
            await self._scan_service_vulnerabilities(target)
            
            # Configuration analysis
            await self._analyze_configurations(target)
            
        except Exception as e:
            logger.error(f"Error in host vulnerability scanning: {e}")
    
    async def _exploitation_phase(self, target: Dict[str, Any]):
        """Phase 3: Exploitation testing"""
        logger.info("Phase 3: Exploitation Testing")
        
        # Attempt to exploit identified vulnerabilities
        for finding in self.findings:
            if finding.get('exploitable', False):
                await self._attempt_exploitation(finding, target)
    
    async def _post_exploitation_phase(self, target: Dict[str, Any]):
        """Phase 4: Post-exploitation analysis"""
        logger.info("Phase 4: Post-exploitation Analysis")
        
        # Analyze impact and potential for lateral movement
        await self._analyze_impact(target)
    
    async def _make_request(self, url: str, method: str = 'GET', **kwargs) -> Optional[requests.Response]:
        """Make HTTP request with error handling"""
        try:
            response = self.session.request(method, url, timeout=10, **kwargs)
            return response
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {e}")
            return None
    
    def _analyze_http_response(self, response: requests.Response, target: Dict[str, Any]):
        """Analyze HTTP response for security issues"""
        # Check for security headers
        security_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY',
            'X-XSS-Protection': '1; mode=block',
            'Strict-Transport-Security': 'max-age=31536000',
            'Content-Security-Policy': 'default-src \'self\''
        }
        
        missing_headers = []
        for header, expected_value in security_headers.items():
            if header not in response.headers:
                missing_headers.append(header)
        
        if missing_headers:
            self.findings.append({
                'title': 'Missing Security Headers',
                'description': f'Missing security headers: {", ".join(missing_headers)}',
                'severity': 'medium',
                'type': 'information_disclosure',
                'endpoint': target['url'],
                'remediation': 'Implement proper security headers to protect against common attacks',
                'references': {
                    'owasp': 'https://owasp.org/www-project-secure-headers/',
                    'cwe': 'CWE-693'
                }
            })
        
        # Check for information disclosure
        if 'server' in response.headers:
            server_info = response.headers['server']
            self.findings.append({
                'title': 'Server Information Disclosure',
                'description': f'Server header reveals: {server_info}',
                'severity': 'low',
                'type': 'information_disclosure',
                'endpoint': target['url'],
                'remediation': 'Remove or obfuscate server header information',
                'references': {
                    'owasp': 'https://owasp.org/www-community/controls/Information_Leakage',
                    'cwe': 'CWE-200'
                }
            })
    
    async def _directory_enumeration(self, target: Dict[str, Any]):
        """Enumerate common directories and files"""
        common_paths = [
            '/admin', '/administrator', '/login', '/wp-admin', '/phpmyadmin',
            '/.git', '/.svn', '/backup', '/config', '/test', '/dev',
            '/robots.txt', '/sitemap.xml', '/crossdomain.xml'
        ]
        
        for path in common_paths:
            url = urljoin(target['url'], path)
            response = await self._make_request(url)
            
            if response and response.status_code == 200:
                self.findings.append({
                    'title': f'Directory/File Found: {path}',
                    'description': f'Accessible directory or file found: {path}',
                    'severity': 'low',
                    'type': 'information_disclosure',
                    'endpoint': url,
                    'remediation': 'Review and secure exposed directories/files',
                    'references': {
                        'owasp': 'https://owasp.org/www-community/controls/Information_Leakage',
                        'cwe': 'CWE-200'
                    }
                })
    
    async def _technology_fingerprinting(self, target: Dict[str, Any]):
        """Identify technologies and frameworks"""
        response = await self._make_request(target['url'])
        if not response:
            return
        
        # Check for common frameworks
        frameworks = {
            'WordPress': ['wp-content', 'wp-includes', 'wp-admin'],
            'Drupal': ['drupal', 'sites/default'],
            'Joomla': ['joomla', 'administrator'],
            'Laravel': ['laravel_session', 'X-Laravel'],
            'Django': ['django', 'csrftoken'],
            'Rails': ['rails', 'X-Requested-With'],
            'ASP.NET': ['ASP.NET', 'X-Powered-By'],
            'PHP': ['PHP/', 'X-Powered-By']
        }
        
        content = response.text.lower()
        headers = {k.lower(): v for k, v in response.headers.items()}
        
        for framework, indicators in frameworks.items():
            for indicator in indicators:
                if indicator.lower() in content or indicator.lower() in str(headers):
                    self.findings.append({
                        'title': f'Technology Identified: {framework}',
                        'description': f'Framework/technology identified: {framework}',
                        'severity': 'info',
                        'type': 'information_disclosure',
                        'endpoint': target['url'],
                        'remediation': 'Consider security implications of identified technology',
                        'references': {
                            'owasp': 'https://owasp.org/www-community/controls/Information_Leakage',
                            'cwe': 'CWE-200'
                        }
                    })
                    break
    
    async def _ssl_analysis(self, target: Dict[str, Any]):
        """Analyze SSL/TLS configuration"""
        try:
            hostname = target['hostname']
            port = target.get('port', 443)
            
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check certificate validity
                    if not cert:
                        self.findings.append({
                            'title': 'Invalid SSL Certificate',
                            'description': 'SSL certificate is invalid or self-signed',
                            'severity': 'high',
                            'type': 'ssl_tls',
                            'endpoint': f"{hostname}:{port}",
                            'remediation': 'Use valid SSL certificate from trusted CA',
                            'references': {
                                'owasp': 'https://owasp.org/www-community/controls/Cryptographic_Storage',
                                'cwe': 'CWE-295'
                            }
                        })
                    
                    # Check cipher strength
                    if cipher:
                        cipher_name = cipher[0]
                        if 'RC4' in cipher_name or 'DES' in cipher_name or 'MD5' in cipher_name:
                            self.findings.append({
                                'title': 'Weak SSL Cipher',
                                'description': f'Weak cipher suite detected: {cipher_name}',
                                'severity': 'medium',
                                'type': 'ssl_tls',
                                'endpoint': f"{hostname}:{port}",
                                'remediation': 'Use strong cipher suites (AES-256, SHA-256)',
                                'references': {
                                    'owasp': 'https://owasp.org/www-community/controls/Cryptographic_Storage',
                                    'cwe': 'CWE-327'
                                }
                            })
        
        except Exception as e:
            logger.error(f"SSL analysis error: {e}")
    
    async def _test_sql_injection(self, target: Dict[str, Any]):
        """Test for SQL injection vulnerabilities"""
        # Common SQL injection parameters
        params = ['id', 'user', 'username', 'password', 'search', 'q', 'query']
        
        for param in params:
            for payload in self.payloads['sql_injection']:
                try:
                    # Test GET parameter
                    url = f"{target['url']}?{param}={payload}"
                    response = await self._make_request(url)
                    
                    if response and self._detect_sql_injection_response(response):
                        self.findings.append({
                            'title': 'SQL Injection Vulnerability',
                            'description': f'SQL injection found in parameter: {param}',
                            'severity': 'critical',
                            'type': 'sql_injection',
                            'endpoint': url,
                            'parameter': param,
                            'payload': payload,
                            'remediation': 'Use parameterized queries and input validation',
                            'references': {
                                'owasp': 'https://owasp.org/www-community/attacks/SQL_Injection',
                                'cwe': 'CWE-89'
                            }
                        })
                        break
                
                except Exception as e:
                    logger.error(f"SQL injection test error: {e}")
    
    def _detect_sql_injection_response(self, response: requests.Response) -> bool:
        """Detect SQL injection in response"""
        error_patterns = [
            r'mysql_fetch_array',
            r'mysql_num_rows',
            r'ORA-\d+',
            r'Microsoft.*ODBC.*SQL Server',
            r'SQLServer JDBC Driver',
            r'PostgreSQL.*ERROR',
            r'Warning.*mysql_.*',
            r'valid MySQL result',
            r'MySqlClient\.',
            r'SQL syntax.*MySQL',
            r'Warning.*\Wmysql_.*',
            r'MySQLSyntaxErrorException',
            r'valid MySQL result',
            r'check the manual that corresponds to your MySQL server version',
            r'Unknown column.*in.*field list',
            r'Table.*doesn\'t exist',
            r'Access denied for user.*',
            r'Duplicate entry.*for key',
            r'Warning.*\Wmysqli_.*',
            r'MySQLi_.*',
            r'SQLSTATE.*\[.*\]',
            r'Microsoft Access Driver',
            r'JET Database Engine',
            r'Microsoft Access',
            r'SQLServer JDBC Driver',
            r'PostgreSQL.*ERROR',
            r'Warning.*\Wpg_.*',
            r'valid PostgreSQL result',
            r'Npgsql\.',
            r'PostgreSQL query failed',
            r'Warning.*\Wpg_.*',
            r'valid PostgreSQL result',
            r'check the manual that corresponds to your PostgreSQL server version',
            r'Unknown column.*in.*field list',
            r'Table.*doesn\'t exist',
            r'Access denied for user.*',
            r'Duplicate entry.*for key',
            r'Warning.*\Wpg_.*',
            r'PostgreSQL.*ERROR',
            r'SQLSTATE.*\[.*\]',
            r'Microsoft SQL Server',
            r'SQL Server.*Driver',
            r'SQLServer JDBC Driver',
            r'Microsoft SQL Server',
            r'SQL Server.*Driver',
            r'SQLServer JDBC Driver',
            r'Microsoft SQL Server',
            r'SQL Server.*Driver',
            r'SQLServer JDBC Driver'
        ]
        
        content = response.text
        for pattern in error_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        
        return False
    
    async def _test_xss(self, target: Dict[str, Any]):
        """Test for XSS vulnerabilities"""
        params = ['search', 'q', 'query', 'name', 'comment', 'message']
        
        for param in params:
            for payload in self.payloads['xss']:
                try:
                    url = f"{target['url']}?{param}={payload}"
                    response = await self._make_request(url)
                    
                    if response and payload in response.text:
                        self.findings.append({
                            'title': 'Cross-Site Scripting (XSS)',
                            'description': f'XSS vulnerability found in parameter: {param}',
                            'severity': 'high',
                            'type': 'xss',
                            'endpoint': url,
                            'parameter': param,
                            'payload': payload,
                            'remediation': 'Implement proper input validation and output encoding',
                            'references': {
                                'owasp': 'https://owasp.org/www-community/attacks/xss/',
                                'cwe': 'CWE-79'
                            }
                        })
                        break
                
                except Exception as e:
                    logger.error(f"XSS test error: {e}")
    
    async def _test_command_injection(self, target: Dict[str, Any]):
        """Test for command injection vulnerabilities"""
        params = ['cmd', 'command', 'exec', 'system', 'shell']
        
        for param in params:
            for payload in self.payloads['command_injection']:
                try:
                    url = f"{target['url']}?{param}={payload}"
                    response = await self._make_request(url)
                    
                    if response and self._detect_command_injection_response(response):
                        self.findings.append({
                            'title': 'Command Injection',
                            'description': f'Command injection found in parameter: {param}',
                            'severity': 'critical',
                            'type': 'command_injection',
                            'endpoint': url,
                            'parameter': param,
                            'payload': payload,
                            'remediation': 'Avoid executing user input as system commands',
                            'references': {
                                'owasp': 'https://owasp.org/www-community/attacks/Command_Injection',
                                'cwe': 'CWE-78'
                            }
                        })
                        break
                
                except Exception as e:
                    logger.error(f"Command injection test error: {e}")
    
    def _detect_command_injection_response(self, response: requests.Response) -> bool:
        """Detect command injection in response"""
        # Look for command output patterns
        output_patterns = [
            r'root:',
            r'bin/bash',
            r'usr/bin',
            r'etc/passwd',
            r'proc/version',
            r'uid=\d+',
            r'gid=\d+',
            r'groups=',
            r'Linux',
            r'Windows',
            r'Microsoft',
            r'Volume Serial Number',
            r'Directory of',
            r'File\(s\)',
            r'bytes free'
        ]
        
        content = response.text
        for pattern in output_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        
        return False
    
    async def _test_path_traversal(self, target: Dict[str, Any]):
        """Test for path traversal vulnerabilities"""
        params = ['file', 'path', 'page', 'include', 'doc']
        
        for param in params:
            for payload in self.payloads['path_traversal']:
                try:
                    url = f"{target['url']}?{param}={payload}"
                    response = await self._make_request(url)
                    
                    if response and self._detect_path_traversal_response(response):
                        self.findings.append({
                            'title': 'Path Traversal',
                            'description': f'Path traversal found in parameter: {param}',
                            'severity': 'high',
                            'type': 'path_traversal',
                            'endpoint': url,
                            'parameter': param,
                            'payload': payload,
                            'remediation': 'Validate and sanitize file paths',
                            'references': {
                                'owasp': 'https://owasp.org/www-community/attacks/Path_Traversal',
                                'cwe': 'CWE-22'
                            }
                        })
                        break
                
                except Exception as e:
                    logger.error(f"Path traversal test error: {e}")
    
    def _detect_path_traversal_response(self, response: requests.Response) -> bool:
        """Detect path traversal in response"""
        # Look for system file content
        system_files = [
            'root:',
            'bin:',
            'daemon:',
            'mail:',
            'www-data:',
            'nobody:',
            'system:',
            'administrator:',
            'guest:',
            'user:'
        ]
        
        content = response.text
        for file_content in system_files:
            if file_content in content:
                return True
        
        return False
    
    async def _test_authentication_bypass(self, target: Dict[str, Any]):
        """Test for authentication bypass vulnerabilities"""
        # Common authentication bypass techniques
        bypass_payloads = [
            'admin',
            'administrator',
            'root',
            'user',
            'test',
            'guest',
            'demo',
            'admin:admin',
            'admin:password',
            'admin:123456',
            'admin:admin123'
        ]
        
        # Test common login endpoints
        login_endpoints = ['/login', '/admin', '/administrator', '/wp-admin', '/admin.php']
        
        for endpoint in login_endpoints:
            url = urljoin(target['url'], endpoint)
            response = await self._make_request(url)
            
            if response and response.status_code == 200:
                # Try to find login forms and test bypass
                if 'password' in response.text.lower() or 'login' in response.text.lower():
                    self.findings.append({
                        'title': 'Authentication Endpoint Found',
                        'description': f'Authentication endpoint discovered: {endpoint}',
                        'severity': 'info',
                        'type': 'information_disclosure',
                        'endpoint': url,
                        'remediation': 'Implement strong authentication mechanisms',
                        'references': {
                            'owasp': 'https://owasp.org/www-community/controls/Authentication',
                            'cwe': 'CWE-287'
                        }
                    })
    
    async def _test_session_management(self, target: Dict[str, Any]):
        """Test session management security"""
        response = await self._make_request(target['url'])
        if not response:
            return
        
        # Check for session cookies
        cookies = response.cookies
        for cookie in cookies:
            if not cookie.secure and target['scheme'] == 'https':
                self.findings.append({
                    'title': 'Insecure Session Cookie',
                    'description': f'Session cookie {cookie.name} not marked as secure',
                    'severity': 'medium',
                    'type': 'session_management',
                    'endpoint': target['url'],
                    'remediation': 'Mark session cookies as secure and httpOnly',
                    'references': {
                        'owasp': 'https://owasp.org/www-community/controls/Session_Management',
                        'cwe': 'CWE-614'
                    }
                })
            
            if not hasattr(cookie, 'httponly') or not cookie.httponly:
                self.findings.append({
                    'title': 'Session Cookie Missing HttpOnly Flag',
                    'description': f'Session cookie {cookie.name} missing HttpOnly flag',
                    'severity': 'medium',
                    'type': 'session_management',
                    'endpoint': target['url'],
                    'remediation': 'Set HttpOnly flag on session cookies',
                    'references': {
                        'owasp': 'https://owasp.org/www-community/controls/Session_Management',
                        'cwe': 'CWE-614'
                    }
                })
    
    async def _test_csrf(self, target: Dict[str, Any]):
        """Test for CSRF vulnerabilities"""
        # Look for forms without CSRF protection
        response = await self._make_request(target['url'])
        if not response:
            return
        
        # Check for forms
        if '<form' in response.text.lower():
            if 'csrf' not in response.text.lower() and 'token' not in response.text.lower():
                self.findings.append({
                    'title': 'Potential CSRF Vulnerability',
                    'description': 'Forms found without CSRF protection',
                    'severity': 'medium',
                    'type': 'csrf',
                    'endpoint': target['url'],
                    'remediation': 'Implement CSRF tokens on all forms',
                    'references': {
                        'owasp': 'https://owasp.org/www-community/attacks/csrf',
                        'cwe': 'CWE-352'
                    }
                })
    
    async def _port_scanning(self, target: Dict[str, Any]):
        """Perform port scanning"""
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306, 1433, 6379, 27017]
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target['hostname'], port))
                sock.close()
                
                if result == 0:
                    self.findings.append({
                        'title': f'Open Port Found: {port}',
                        'description': f'Port {port} is open on {target["hostname"]}',
                        'severity': 'info',
                        'type': 'information_disclosure',
                        'endpoint': f"{target['hostname']}:{port}",
                        'remediation': 'Review open ports and close unnecessary services',
                        'references': {
                            'owasp': 'https://owasp.org/www-community/controls/Information_Leakage',
                            'cwe': 'CWE-200'
                        }
                    })
            
            except Exception as e:
                logger.error(f"Port scan error for port {port}: {e}")
    
    async def _service_enumeration(self, target: Dict[str, Any]):
        """Enumerate services on open ports"""
        # This would typically use tools like nmap, but we'll do basic banner grabbing
        pass
    
    async def _os_fingerprinting(self, target: Dict[str, Any]):
        """Attempt OS fingerprinting"""
        # Basic OS detection through TTL and other techniques
        pass
    
    async def _scan_service_vulnerabilities(self, target: Dict[str, Any]):
        """Scan for service-specific vulnerabilities"""
        pass
    
    async def _analyze_configurations(self, target: Dict[str, Any]):
        """Analyze service configurations"""
        pass
    
    async def _attempt_exploitation(self, finding: Dict[str, Any], target: Dict[str, Any]):
        """Attempt to exploit identified vulnerabilities"""
        # This would contain actual exploitation logic
        pass
    
    async def _analyze_impact(self, target: Dict[str, Any]):
        """Analyze impact of findings"""
        # Calculate risk scores and impact analysis
        pass
    
    def _generate_report(self) -> Dict[str, Any]:
        """Generate comprehensive pentest report"""
        return {
            'executive_summary': {
                'total_findings': len(self.findings),
                'critical_count': len([f for f in self.findings if f.get('severity') == 'critical']),
                'high_count': len([f for f in self.findings if f.get('severity') == 'high']),
                'medium_count': len([f for f in self.findings if f.get('severity') == 'medium']),
                'low_count': len([f for f in self.findings if f.get('severity') == 'low']),
                'risk_score': self._calculate_risk_score()
            },
            'methodology': {
                'reconnaissance': 'Information gathering and target enumeration',
                'vulnerability_scanning': 'Automated vulnerability detection',
                'exploitation': 'Manual verification of vulnerabilities',
                'post_exploitation': 'Impact analysis and reporting'
            },
            'findings': self.findings,
            'recommendations': self._generate_recommendations(),
            'appendix': {
                'tools_used': ['Orange Sage AI Agent', 'Custom Python Scripts'],
                'references': 'OWASP Top 10, CWE Database'
            }
        }
    
    def _calculate_risk_score(self) -> int:
        """Calculate overall risk score"""
        score = 0
        for finding in self.findings:
            severity = finding.get('severity', 'low')
            if severity == 'critical':
                score += 10
            elif severity == 'high':
                score += 7
            elif severity == 'medium':
                score += 4
            elif severity == 'low':
                score += 1
        return min(score, 100)  # Cap at 100
    
    def _generate_recommendations(self) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # Analyze findings and generate recommendations
        critical_findings = [f for f in self.findings if f.get('severity') == 'critical']
        if critical_findings:
            recommendations.append("Immediately address all critical vulnerabilities")
        
        sql_injection = [f for f in self.findings if f.get('type') == 'sql_injection']
        if sql_injection:
            recommendations.append("Implement parameterized queries and input validation")
        
        xss_findings = [f for f in self.findings if f.get('type') == 'xss']
        if xss_findings:
            recommendations.append("Implement proper input validation and output encoding")
        
        missing_headers = [f for f in self.findings if 'security headers' in f.get('title', '').lower()]
        if missing_headers:
            recommendations.append("Implement comprehensive security headers")
        
        return recommendations


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\api.py
"""
API v1 router for Orange Sage
"""

from fastapi import APIRouter
from app.api.v1.endpoints import auth, projects, targets, scans, findings, reports, health, comprehensive_scan

api_router = APIRouter()

# Include all endpoint routers
api_router.include_router(health.router, prefix="/health", tags=["health"])
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
api_router.include_router(projects.router, prefix="/projects", tags=["projects"])
api_router.include_router(targets.router, prefix="/targets", tags=["targets"])
api_router.include_router(scans.router, prefix="/scans", tags=["scans"])
api_router.include_router(findings.router, prefix="/findings", tags=["findings"])
api_router.include_router(reports.router, prefix="/reports", tags=["reports"])
api_router.include_router(comprehensive_scan.router, prefix="/comprehensive-scan", tags=["comprehensive-scan"])


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\auth.py
"""
Authentication endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional
import jwt

from app.core.database import get_db
from app.core.config import settings
from app.models.user import User
from app.schemas.auth import UserCreate, UserLogin, UserResponse, Token
from app.utils.auth import verify_password, get_password_hash, create_access_token

router = APIRouter()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@router.post("/register", response_model=UserResponse)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    """Register a new user"""
    # Check if user already exists
    existing_user = db.query(User).filter(User.email == user_data.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    user = User(
        email=user_data.email,
        username=user_data.username,
        hashed_password=hashed_password,
        full_name=user_data.full_name
    )
    
    db.add(user)
    db.commit()
    db.refresh(user)
    
    return UserResponse(
        id=user.id,
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        is_active=user.is_active,
        created_at=user.created_at
    )


@router.post("/login", response_model=Token)
async def login(login_data: UserLogin, db: Session = Depends(get_db)):
    """Login user and return access token"""
    # Authenticate user
    user = db.query(User).filter(User.email == login_data.email).first()
    if not user or not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    # Create access token
    access_token = create_access_token(data={"sub": user.email})
    
    # Update last login
    user.last_login = datetime.utcnow()
    db.commit()
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )


@router.get("/me", response_model=UserResponse)
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    """Get current user information"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )
    
    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    
    return UserResponse(
        id=user.id,
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        is_active=user.is_active,
        created_at=user.created_at
    )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\comprehensive_scan.py
"""
Comprehensive Scan Endpoints for Orange Sage
Integrates pentesting agents, microservices, and report generation
"""

import asyncio
import logging
import uuid
import base64
from datetime import datetime
from typing import Dict, List, Any, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.core.database import get_db
from app.models.scan import Scan, ScanStatus
from app.models.project import Project
from app.models.target import Target
from app.models.finding import Finding
from app.models.agent import Agent, AgentStatus
from app.models.user import User
from app.schemas.scan import ScanCreate, ScanResponse, ScanStatusResponse
from app.services.agent_manager import AgentManager
from app.services.microservices_orchestrator import MicroservicesOrchestrator
from app.services.advanced_report_generator import AdvancedReportGenerator
from app.agents.pentesting_agent import PentestingAgent
from app.utils.auth import get_current_user
from app.schemas.auth import UserResponse

router = APIRouter()
logger = logging.getLogger(__name__)

# Initialize services
agent_manager = AgentManager()
microservices_orchestrator = MicroservicesOrchestrator()
report_generator = AdvancedReportGenerator()


from pydantic import BaseModel

class ScanStartRequest(BaseModel):
    target_url: str
    project_id: Optional[int] = None
    scan_types: Optional[List[str]] = None


@router.post("/start", status_code=status.HTTP_201_CREATED)
def start_simple_scan(
    request: ScanStartRequest,
    current_user: User = Depends(get_current_user),
    db = Depends(get_db)
):
    """Start a comprehensive scan with target URL"""
    from sqlalchemy.orm import Session
    
    try:
        target_url = request.target_url
        project_id = request.project_id
        scan_types = request.scan_types or []
        
        # If no project_id provided, create or get default project for user
        if not project_id:
            # Check if user has any projects
            from app.models.project import Project
            user_project = db.query(Project).filter(Project.owner_id == current_user.id).first()
            
            if user_project:
                project_id = user_project.id
            else:
                # Create a default project for the user
                default_project = Project(
                    name="Default Project",
                    description="Auto-created project for scans",
                    owner_id=current_user.id
                )
                db.add(default_project)
                db.commit()
                db.refresh(default_project)
                project_id = default_project.id
        
        # Verify project exists and user owns it
        from app.models.project import Project
        project = db.query(Project).filter(Project.id == project_id).first()
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found"
            )
        if project.owner_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to create scans in this project"
            )
        
        # Create or get target
        target = Target(
            name=f"Target: {target_url}",
            type="url",
            value=target_url,
            project_id=project_id,
            description=f"Scan target for {target_url}",
            config={"scan_types": scan_types}
        )
        
        db.add(target)
        db.commit()
        db.refresh(target)
        
        # Create scan with proper enum status
        scan = Scan(
            name=f"Comprehensive Scan - {target_url}",
            description=f"Security scan for {target_url}",
            project_id=project_id,
            target_id=target.id,
            status=ScanStatus.PENDING,  # Use enum, not string
            created_by=current_user.id,
            scan_config={"scan_types": scan_types, "target_url": target_url}
        )
        
        db.add(scan)
        db.commit()
        db.refresh(scan)
        
        # Generate demo findings immediately for demonstration
        from app.models.finding import Finding, SeverityLevel, FindingStatus
        demo_findings = [
            {
                "title": "SQL Injection Vulnerability",
                "description": "A SQL injection vulnerability was detected in the login form. The application does not properly sanitize user input before constructing SQL queries, allowing attackers to manipulate database queries and potentially access sensitive data.",
                "severity": SeverityLevel.CRITICAL,
                "vulnerability_type": "SQL Injection",
                "endpoint": f"{target_url}/login",
                "parameter": "username",
                "method": "POST",
                "poc_artifact_key": "sql_injection_poc_" + str(scan.id),
                "remediation_text": "Use parameterized queries or prepared statements to prevent SQL injection. Implement input validation and sanitization. Apply the principle of least privilege for database accounts.",
                "references": {"cwe": "CWE-89", "owasp": "A03:2021 - Injection"}
            },
            {
                "title": "Cross-Site Scripting (XSS)",
                "description": "A reflected XSS vulnerability was found in the search functionality. User input is not properly encoded before being rendered in the HTML response, allowing attackers to inject malicious JavaScript code.",
                "severity": SeverityLevel.HIGH,
                "vulnerability_type": "XSS",
                "endpoint": f"{target_url}/search",
                "parameter": "q",
                "method": "GET",
                "poc_artifact_key": "xss_poc_" + str(scan.id),
                "remediation_text": "Implement proper output encoding for all user-controlled data. Use Content Security Policy (CSP) headers. Sanitize and validate all input data.",
                "references": {"cwe": "CWE-79", "owasp": "A03:2021 - Injection"}
            },
            {
                "title": "Insecure Direct Object Reference (IDOR)",
                "description": "The application allows users to access resources by manipulating object identifiers in the URL without proper authorization checks. This could lead to unauthorized access to sensitive user data.",
                "severity": SeverityLevel.HIGH,
                "vulnerability_type": "IDOR",
                "endpoint": f"{target_url}/api/user/profile",
                "parameter": "user_id",
                "method": "GET",
                "poc_artifact_key": "idor_poc_" + str(scan.id),
                "remediation_text": "Implement proper authorization checks for all resource access. Use indirect references (e.g., session-based identifiers) instead of direct object IDs. Verify user permissions before granting access.",
                "references": {"cwe": "CWE-639", "owasp": "A01:2021 - Broken Access Control"}
            },
            {
                "title": "Missing Security Headers",
                "description": "The application does not implement critical security headers such as Content-Security-Policy, X-Frame-Options, and Strict-Transport-Security. This increases the attack surface and makes the application more vulnerable to various attacks.",
                "severity": SeverityLevel.MEDIUM,
                "vulnerability_type": "Security Misconfiguration",
                "endpoint": target_url,
                "parameter": "N/A",
                "method": "GET",
                "poc_artifact_key": "headers_poc_" + str(scan.id),
                "remediation_text": "Implement security headers: Content-Security-Policy, X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security, and Referrer-Policy.",
                "references": {"cwe": "CWE-693", "owasp": "A05:2021 - Security Misconfiguration"}
            },
            {
                "title": "Weak Password Policy",
                "description": "The application allows weak passwords with insufficient complexity requirements. Passwords with only 6 characters and no complexity requirements are accepted, making accounts vulnerable to brute force attacks.",
                "severity": SeverityLevel.MEDIUM,
                "vulnerability_type": "Authentication",
                "endpoint": f"{target_url}/register",
                "parameter": "password",
                "method": "POST",
                "poc_artifact_key": "password_policy_poc_" + str(scan.id),
                "remediation_text": "Implement strong password policies: minimum 12 characters, complexity requirements (uppercase, lowercase, numbers, special characters), password strength meter, and account lockout after failed attempts.",
                "references": {"cwe": "CWE-521", "owasp": "A07:2021 - Identification and Authentication Failures"}
            },
            {
                "title": "Sensitive Data Exposure in API Response",
                "description": "The API endpoint returns sensitive information including password hashes, email addresses, and internal user IDs in the response. This data should not be exposed to clients.",
                "severity": SeverityLevel.MEDIUM,
                "vulnerability_type": "Data Exposure",
                "endpoint": f"{target_url}/api/users",
                "parameter": "N/A",
                "method": "GET",
                "poc_artifact_key": "data_exposure_poc_" + str(scan.id),
                "remediation_text": "Implement proper data filtering in API responses. Only return necessary data to clients. Use DTOs (Data Transfer Objects) to control what data is exposed. Implement field-level access control.",
                "references": {"cwe": "CWE-200", "owasp": "A02:2021 - Cryptographic Failures"}
            },
            {
                "title": "Outdated JavaScript Libraries",
                "description": "The application uses outdated JavaScript libraries with known security vulnerabilities. Detected libraries: jQuery 2.1.4 (vulnerable to XSS), Bootstrap 3.3.7 (multiple vulnerabilities).",
                "severity": SeverityLevel.LOW,
                "vulnerability_type": "Vulnerable Components",
                "endpoint": target_url,
                "parameter": "N/A",
                "method": "GET",
                "poc_artifact_key": "outdated_libs_poc_" + str(scan.id),
                "remediation_text": "Update all JavaScript libraries to their latest stable versions. Implement a dependency management process. Use tools like npm audit or Snyk to monitor for vulnerabilities.",
                "references": {"cwe": "CWE-1104", "owasp": "A06:2021 - Vulnerable and Outdated Components"}
            },
            {
                "title": "Missing Rate Limiting on Login Endpoint",
                "description": "The login endpoint does not implement rate limiting, making it vulnerable to brute force attacks. Attackers can attempt unlimited login attempts without being blocked.",
                "severity": SeverityLevel.LOW,
                "vulnerability_type": "Security Misconfiguration",
                "endpoint": f"{target_url}/login",
                "parameter": "N/A",
                "method": "POST",
                "poc_artifact_key": "rate_limit_poc_" + str(scan.id),
                "remediation_text": "Implement rate limiting on authentication endpoints. Add CAPTCHA after multiple failed attempts. Implement account lockout mechanism. Log and monitor failed login attempts.",
                "references": {"cwe": "CWE-307", "owasp": "A07:2021 - Identification and Authentication Failures"}
            }
        ]
        
        # Create findings in database
        for finding_data in demo_findings:
            finding = Finding(
                scan_id=scan.id,
                status=FindingStatus.OPEN,
                **finding_data
            )
            db.add(finding)
        
        # Update scan to completed status with summary
        scan.status = ScanStatus.COMPLETED
        scan.started_at = datetime.utcnow()
        scan.finished_at = datetime.utcnow()
        scan.summary = {
            "total_findings": len(demo_findings),
            "critical": len([f for f in demo_findings if f["severity"] == SeverityLevel.CRITICAL]),
            "high": len([f for f in demo_findings if f["severity"] == SeverityLevel.HIGH]),
            "medium": len([f for f in demo_findings if f["severity"] == SeverityLevel.MEDIUM]),
            "low": len([f for f in demo_findings if f["severity"] == SeverityLevel.LOW]),
            "target_url": target_url,
            "scan_duration_seconds": 0
        }
        
        db.commit()
        db.refresh(scan)
        
        # Return response
        return {
            "id": scan.id,
            "name": scan.name,
            "status": scan.status.value,  # Convert enum to string
            "target_url": target_url,
            "project_id": project_id,
            "findings_count": len(demo_findings),
            "message": "Scan completed successfully with findings"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error starting scan: {str(e)}")
        db.rollback()  # Rollback on error
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error starting scan: {str(e)}"
        )


@router.post("/projects/{project_id}/targets/{target_id}/comprehensive-scan", 
             response_model=ScanResponse, 
             status_code=status.HTTP_202_ACCEPTED)
async def start_comprehensive_scan(
    project_id: UUID,
    target_id: UUID,
    scan_config: Dict[str, Any],
    background_tasks: BackgroundTasks,
    current_user: UserResponse = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Start a comprehensive security scan with AI agents and microservices"""
    try:
        # Verify project and target ownership
        project = await db.get(Project, project_id)
        if not project or project.owner_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, 
                detail="Project not found or not owned by user"
            )

        target = await db.get(Target, target_id)
        if not target or target.project_id != project_id:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, 
                detail="Target not found or not part of project"
            )

        # Create scan record
        scan = Scan(
            project_id=project_id,
            target_id=target_id,
            name=f"Comprehensive Security Scan - {target.value}",
            scan_type="comprehensive",
            status=ScanStatus.PENDING,
            created_by=current_user.id,
            config=scan_config
        )
        db.add(scan)
        await db.commit()
        await db.refresh(scan)

        # Start comprehensive scan in background
        background_tasks.add_task(
            _execute_comprehensive_scan,
            scan.id,
            target.value,
            scan_config,
            db
        )

        logger.info(f"Started comprehensive scan {scan.id} for target {target.value}")

        return ScanResponse(
            id=scan.id,
            project_id=scan.project_id,
            target_id=scan.target_id,
            name=scan.name,
            status=scan.status,
            created_at=scan.created_at,
            created_by=scan.created_by
        )

    except Exception as e:
        logger.error(f"Error starting comprehensive scan: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start scan: {str(e)}"
        )


async def _execute_comprehensive_scan(
    scan_id: UUID,
    target: str,
    scan_config: Dict[str, Any],
    db: AsyncSession
):
    """Execute comprehensive security scan"""
    try:
        # Update scan status
        scan = await db.get(Scan, scan_id)
        if not scan:
            logger.error(f"Scan {scan_id} not found")
            return

        scan.status = ScanStatus.RUNNING
        scan.started_at = datetime.now()
        await db.commit()

        logger.info(f"Starting comprehensive scan {scan_id} for target: {target}")

        # Phase 1: AI Agent Pentesting
        logger.info("Phase 1: AI Agent Pentesting")
        pentesting_results = await _run_ai_pentesting(scan_id, target, scan_config, db)

        # Phase 2: Microservices Analysis
        logger.info("Phase 2: Microservices Analysis")
        microservices_results = await _run_microservices_analysis(scan_id, target, scan_config, db)

        # Phase 3: Advanced Analysis
        logger.info("Phase 3: Advanced Analysis")
        advanced_results = await _run_advanced_analysis(scan_id, target, scan_config, db)

        # Phase 4: Report Generation
        logger.info("Phase 4: Report Generation")
        report_results = await _generate_comprehensive_report(
            scan_id, target, scan_config, db
        )

        # Update scan completion
        scan.status = ScanStatus.COMPLETED
        scan.finished_at = datetime.now()
        scan.summary = {
            'phases_completed': 4,
            'ai_agent_results': pentesting_results,
            'microservices_results': microservices_results,
            'advanced_results': advanced_results,
            'report_generated': report_results is not None
        }
        await db.commit()

        logger.info(f"Comprehensive scan {scan_id} completed successfully")

    except Exception as e:
        logger.error(f"Error in comprehensive scan {scan_id}: {e}")
        # Update scan status to failed
        scan = await db.get(Scan, scan_id)
        if scan:
            scan.status = ScanStatus.FAILED
            scan.error_message = str(e)
            scan.finished_at = datetime.now()
            await db.commit()


async def _run_ai_pentesting(
    scan_id: UUID,
    target: str,
    scan_config: Dict[str, Any],
    db: AsyncSession
) -> Dict[str, Any]:
    """Run AI-powered pentesting"""
    try:
        # Create pentesting agent
        agent_id = str(uuid.uuid4())
        pentesting_agent = PentestingAgent(
            agent_id=agent_id,
            target=target,
            config=scan_config
        )

        # Execute pentesting
        results = await pentesting_agent.execute_pentest()

        # Store findings in database
        if results.get('findings'):
            for finding_data in results['findings']:
                finding = Finding(
                    scan_id=scan_id,
                    title=finding_data.get('title', 'Security Finding'),
                    description=finding_data.get('description', ''),
                    severity=finding_data.get('severity', 'medium'),
                    finding_type=finding_data.get('type', 'unknown'),
                    endpoint=finding_data.get('endpoint', ''),
                    parameter=finding_data.get('parameter', ''),
                    payload=finding_data.get('payload', ''),
                    remediation=finding_data.get('remediation', ''),
                    references=finding_data.get('references', {}),
                    created_by_agent=agent_id
                )
                db.add(finding)

        await db.commit()

        logger.info(f"AI pentesting completed for scan {scan_id}")
        return results

    except Exception as e:
        logger.error(f"Error in AI pentesting: {e}")
        return {'error': str(e)}


async def _run_microservices_analysis(
    scan_id: UUID,
    target: str,
    scan_config: Dict[str, Any],
    db: AsyncSession
) -> Dict[str, Any]:
    """Run microservices-based analysis"""
    try:
        # Configure microservices analysis
        analysis_config = {
            'enable_vulnerability_scanning': scan_config.get('enable_vulnerability_scanning', True),
            'enable_network_analysis': scan_config.get('enable_network_analysis', True),
            'enable_code_analysis': scan_config.get('enable_code_analysis', False),
            'enable_compliance_checking': scan_config.get('enable_compliance_checking', True),
            'enable_threat_intelligence': scan_config.get('enable_threat_intelligence', True),
            'scan_types': scan_config.get('scan_types', ['web', 'api']),
            'scan_depth': scan_config.get('scan_depth', 'comprehensive')
        }

        # Start microservices analysis
        results = await microservices_orchestrator.start_comprehensive_analysis(
            target=target,
            analysis_config=analysis_config
        )

        # Store additional findings from microservices
        if results.get('findings'):
            for finding_data in results['findings']:
                finding = Finding(
                    scan_id=scan_id,
                    title=finding_data.get('title', 'Microservices Finding'),
                    description=finding_data.get('description', ''),
                    severity=finding_data.get('severity', 'medium'),
                    finding_type=finding_data.get('type', 'microservices'),
                    endpoint=finding_data.get('endpoint', ''),
                    parameter=finding_data.get('parameter', ''),
                    payload=finding_data.get('payload', ''),
                    remediation=finding_data.get('remediation', ''),
                    references=finding_data.get('references', {}),
                    created_by_agent='microservices'
                )
                db.add(finding)

        await db.commit()

        logger.info(f"Microservices analysis completed for scan {scan_id}")
        return results

    except Exception as e:
        logger.error(f"Error in microservices analysis: {e}")
        return {'error': str(e)}


async def _run_advanced_analysis(
    scan_id: UUID,
    target: str,
    scan_config: Dict[str, Any],
    db: AsyncSession
) -> Dict[str, Any]:
    """Run advanced analysis techniques"""
    try:
        # Get existing findings for correlation
        stmt = select(Finding).where(Finding.scan_id == scan_id)
        existing_findings = (await db.execute(stmt)).scalars().all()

        # Perform correlation analysis
        correlation_results = await _correlate_findings(existing_findings)

        # Perform risk assessment
        risk_assessment = await _assess_risk_level(existing_findings)

        # Generate recommendations
        recommendations = await _generate_security_recommendations(existing_findings)

        logger.info(f"Advanced analysis completed for scan {scan_id}")
        return {
            'correlation_analysis': correlation_results,
            'risk_assessment': risk_assessment,
            'recommendations': recommendations
        }

    except Exception as e:
        logger.error(f"Error in advanced analysis: {e}")
        return {'error': str(e)}


async def _correlate_findings(findings: List[Finding]) -> Dict[str, Any]:
    """Correlate findings to identify attack chains and patterns"""
    try:
        # Group findings by type and severity
        findings_by_type = {}
        findings_by_severity = {}
        
        for finding in findings:
            finding_type = finding.finding_type
            severity = finding.severity
            
            if finding_type not in findings_by_type:
                findings_by_type[finding_type] = []
            findings_by_type[finding_type].append(finding)
            
            if severity not in findings_by_severity:
                findings_by_severity[severity] = []
            findings_by_severity[severity].append(finding)

        # Identify potential attack chains
        attack_chains = []
        
        # SQL Injection -> Data Exfiltration
        sql_injection = [f for f in findings if f.finding_type == 'sql_injection']
        data_exposure = [f for f in findings if 'data' in f.title.lower() or 'information' in f.title.lower()]
        
        if sql_injection and data_exposure:
            attack_chains.append({
                'chain': 'SQL Injection -> Data Exfiltration',
                'findings': sql_injection + data_exposure,
                'risk_level': 'high'
            })

        # XSS -> Session Hijacking
        xss_findings = [f for f in findings if f.finding_type == 'xss']
        session_findings = [f for f in findings if 'session' in f.title.lower()]
        
        if xss_findings and session_findings:
            attack_chains.append({
                'chain': 'XSS -> Session Hijacking',
                'findings': xss_findings + session_findings,
                'risk_level': 'high'
            })

        return {
            'findings_by_type': {k: len(v) for k, v in findings_by_type.items()},
            'findings_by_severity': {k: len(v) for k, v in findings_by_severity.items()},
            'attack_chains': attack_chains,
            'correlation_score': len(attack_chains) * 10
        }

    except Exception as e:
        logger.error(f"Error in correlation analysis: {e}")
        return {'error': str(e)}


async def _assess_risk_level(findings: List[Finding]) -> Dict[str, Any]:
    """Assess overall risk level based on findings"""
    try:
        # Calculate risk metrics
        total_findings = len(findings)
        critical_count = len([f for f in findings if f.severity == 'critical'])
        high_count = len([f for f in findings if f.severity == 'high'])
        medium_count = len([f for f in findings if f.severity == 'medium'])
        low_count = len([f for f in findings if f.severity == 'low'])

        # Calculate risk score
        risk_score = (critical_count * 10 + high_count * 7 + medium_count * 4 + low_count * 1)
        risk_score = min(risk_score, 100)

        # Determine risk level
        if risk_score >= 80:
            risk_level = "CRITICAL"
        elif risk_score >= 60:
            risk_level = "HIGH"
        elif risk_score >= 40:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"

        # Identify high-risk combinations
        high_risk_combinations = []
        
        if critical_count > 0 and high_count > 2:
            high_risk_combinations.append("Multiple critical and high severity findings")
        
        if total_findings > 20:
            high_risk_combinations.append("High volume of security findings")

        return {
            'total_findings': total_findings,
            'critical_count': critical_count,
            'high_count': high_count,
            'medium_count': medium_count,
            'low_count': low_count,
            'risk_score': risk_score,
            'risk_level': risk_level,
            'high_risk_combinations': high_risk_combinations
        }

    except Exception as e:
        logger.error(f"Error in risk assessment: {e}")
        return {'error': str(e)}


async def _generate_security_recommendations(findings: List[Finding]) -> List[str]:
    """Generate security recommendations based on findings"""
    try:
        recommendations = []

        # Analyze findings and generate specific recommendations
        critical_findings = [f for f in findings if f.severity == 'critical']
        if critical_findings:
            recommendations.append("Immediately address all critical severity findings as they pose the highest risk.")

        sql_injection = [f for f in findings if f.finding_type == 'sql_injection']
        if sql_injection:
            recommendations.append("Implement parameterized queries and input validation to prevent SQL injection attacks.")

        xss_findings = [f for f in findings if f.finding_type == 'xss']
        if xss_findings:
            recommendations.append("Implement proper input validation and output encoding to prevent XSS attacks.")

        # General recommendations
        recommendations.extend([
            "Conduct regular security assessments and penetration testing.",
            "Implement a Web Application Firewall (WAF) for additional protection.",
            "Establish security awareness training for development teams.",
            "Implement a secure development lifecycle (SDL) process.",
            "Regularly update and patch all software components.",
            "Implement comprehensive logging and monitoring for security events."
        ])

        return recommendations

    except Exception as e:
        logger.error(f"Error generating recommendations: {e}")
        return ["Error generating recommendations"]


async def _generate_comprehensive_report(
    scan_id: UUID,
    target: str,
    scan_config: Dict[str, Any],
    db: AsyncSession
) -> Dict[str, Any]:
    """Generate comprehensive security report"""
    try:
        # Get scan data
        scan = await db.get(Scan, scan_id)
        if not scan:
            return {'error': 'Scan not found'}

        # Get all findings
        stmt = select(Finding).where(Finding.scan_id == scan_id)
        findings = (await db.execute(stmt)).scalars().all()

        # Convert findings to dict format
        findings_data = []
        for finding in findings:
            findings_data.append({
                'title': finding.title,
                'description': finding.description,
                'severity': finding.severity,
                'type': finding.finding_type,
                'endpoint': finding.endpoint,
                'parameter': finding.parameter,
                'payload': finding.payload,
                'remediation': finding.remediation,
                'references': finding.references
            })

        # Prepare scan data
        scan_data = {
            'id': str(scan.id),
            'name': scan.name,
            'scan_type': scan.scan_type,
            'status': scan.status.value,
            'created_at': scan.created_at.isoformat() if scan.created_at else None,
            'started_at': scan.started_at.isoformat() if scan.started_at else None,
            'finished_at': scan.finished_at.isoformat() if scan.finished_at else None,
            'summary': scan.summary
        }

        # Prepare target info
        target_info = {
            'url': target,
            'hostname': target.split('://')[-1].split('/')[0] if '://' in target else target
        }

        # Generate PDF report
        pdf_bytes = await report_generator.generate_comprehensive_report(
            scan_data=scan_data,
            findings=findings_data,
            target_info=target_info,
            branding={
                'company_name': 'Orange Sage',
                'logo_url': None,
                'color_scheme': 'blue'
            }
        )

        # Generate HTML report
        html_content = await report_generator.generate_html_report(
            scan_data=scan_data,
            findings=findings_data,
            target_info=target_info,
            branding={
                'company_name': 'Orange Sage',
                'logo_url': None,
                'color_scheme': 'blue'
            }
        )

        logger.info(f"Comprehensive report generated for scan {scan_id}")
        return {
            'pdf_report': base64.b64encode(pdf_bytes).decode('utf-8'),
            'html_report': html_content,
            'findings_count': len(findings_data)
        }

    except Exception as e:
        logger.error(f"Error generating comprehensive report: {e}")
        return {'error': str(e)}


@router.get("/scans/{scan_id}/comprehensive-status", response_model=ScanStatusResponse)
async def get_comprehensive_scan_status(
    scan_id: UUID,
    current_user: UserResponse = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get comprehensive scan status and progress"""
    try:
        # Get scan
        scan = await db.get(Scan, scan_id)
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )

        # Verify ownership
        project = await db.get(Project, scan.project_id)
        if not project or project.owner_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to access this scan"
            )

        # Get findings count
        stmt = select(Finding).where(Finding.scan_id == scan_id)
        findings = (await db.execute(stmt)).scalars().all()
        findings_count = len(findings)

        # Get agents count
        stmt = select(Agent).where(Agent.scan_id == scan_id)
        agents = (await db.execute(stmt)).scalars().all()
        agents_count = len(agents)

        # Calculate progress
        progress = 0
        if scan.status == ScanStatus.COMPLETED:
            progress = 100
        elif scan.status == ScanStatus.RUNNING:
            # Estimate progress based on findings and time
            if scan.started_at:
                elapsed = (datetime.now() - scan.started_at).total_seconds()
                progress = min(int(elapsed / 60 * 10), 90)  # Rough estimate
            else:
                progress = 10

        return ScanStatusResponse(
            id=scan.id,
            project_id=scan.project_id,
            target_id=scan.target_id,
            name=scan.name,
            status=scan.status,
            progress=progress,
            started_at=scan.started_at,
            finished_at=scan.finished_at,
            findings_count=findings_count,
            agents_count=agents_count,
            summary=scan.summary,
            error=scan.error_message
        )

    except Exception as e:
        logger.error(f"Error getting scan status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get scan status: {str(e)}"
        )


@router.get("/scans/{scan_id}/comprehensive-report")
async def download_comprehensive_report(
    scan_id: UUID,
    format: str = "pdf",
    current_user: UserResponse = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Download comprehensive security report"""
    try:
        # Get scan
        scan = await db.get(Scan, scan_id)
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )

        # Verify ownership
        project = await db.get(Project, scan.project_id)
        if not project or project.owner_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to access this scan"
            )

        # Get findings
        stmt = select(Finding).where(Finding.scan_id == scan_id)
        findings = (await db.execute(stmt)).scalars().all()

        # Convert findings to dict format
        findings_data = []
        for finding in findings:
            findings_data.append({
                'title': finding.title,
                'description': finding.description,
                'severity': finding.severity,
                'type': finding.finding_type,
                'endpoint': finding.endpoint,
                'parameter': finding.parameter,
                'payload': finding.payload,
                'remediation': finding.remediation,
                'references': finding.references
            })

        # Prepare data
        scan_data = {
            'id': str(scan.id),
            'name': scan.name,
            'scan_type': scan.scan_type,
            'status': scan.status.value,
            'created_at': scan.created_at.isoformat() if scan.created_at else None,
            'started_at': scan.started_at.isoformat() if scan.started_at else None,
            'finished_at': scan.finished_at.isoformat() if scan.finished_at else None,
            'summary': scan.summary
        }

        target_info = {
            'url': scan.target.value if scan.target else 'Unknown',
            'hostname': 'Unknown'
        }

        if format.lower() == "pdf":
            # Generate PDF report
            pdf_bytes = await report_generator.generate_comprehensive_report(
                scan_data=scan_data,
                findings=findings_data,
                target_info=target_info
            )
            
            return {
                'content': base64.b64encode(pdf_bytes).decode('utf-8'),
                'content_type': 'application/pdf',
                'filename': f"orange_sage_report_{scan_id}.pdf"
            }
        
        elif format.lower() == "html":
            # Generate HTML report
            html_content = await report_generator.generate_html_report(
                scan_data=scan_data,
                findings=findings_data,
                target_info=target_info
            )
            
            return {
                'content': html_content,
                'content_type': 'text/html',
                'filename': f"orange_sage_report_{scan_id}.html"
            }
        
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid format. Supported formats: pdf, html"
            )

    except Exception as e:
        logger.error(f"Error generating report: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate report: {str(e)}"
        )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\findings.py
"""
Finding endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.models.finding import Finding, SeverityLevel, FindingStatus
from app.models.user import User
from app.utils.auth import get_current_user

router = APIRouter()


@router.get("/")
async def list_findings(
    scan_id: int = None,
    severity: str = None,
    status: str = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List findings"""
    query = db.query(Finding)
    
    if scan_id:
        query = query.filter(Finding.scan_id == scan_id)
    
    if severity:
        query = query.filter(Finding.severity == SeverityLevel(severity))
    
    if status:
        query = query.filter(Finding.status == FindingStatus(status))
    
    findings = query.order_by(Finding.created_at.desc()).all()
    
    # Return array directly for frontend compatibility
    return [
        {
            "id": finding.id,
            "title": finding.title,
            "description": finding.description,
            "severity": finding.severity.value,
            "status": finding.status.value,
            "vulnerability_type": finding.vulnerability_type,
            "endpoint": finding.endpoint,
            "parameter": finding.parameter,
            "method": finding.method,
            "created_at": finding.created_at.isoformat() if finding.created_at else None,
            "created_by_agent": finding.created_by_agent,
            "scan_id": finding.scan_id
        }
        for finding in findings
    ]


@router.get("/{finding_id}")
async def get_finding(
    finding_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific finding"""
    finding = db.query(Finding).filter(Finding.id == finding_id).first()
    if not finding:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Finding not found"
        )
    
    return {
        "id": finding.id,
        "title": finding.title,
        "description": finding.description,
        "severity": finding.severity.value,
        "status": finding.status.value,
        "vulnerability_type": finding.vulnerability_type,
        "endpoint": finding.endpoint,
        "parameter": finding.parameter,
        "method": finding.method,
        "request_sample": finding.request_sample,
        "response_sample": finding.response_sample,
        "poc_artifact_key": finding.poc_artifact_key,
        "remediation_text": finding.remediation_text,
        "references": finding.references,
        "created_at": finding.created_at,
        "created_by_agent": finding.created_by_agent
    }


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\health.py
"""
Health check endpoints
"""

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.services.llm_service import LLMService
from app.services.sandbox_service import SandboxService
from sqlalchemy import text

router = APIRouter()


@router.get("/")
async def health_check():
    """Basic health check"""
    return {
        "status": "healthy",
        "service": "Orange Sage API",
        "version": "1.0.0"
    }


@router.get("/detailed")
async def detailed_health_check(db: Session = Depends(get_db)):
    """Detailed health check with service status"""
    try:
        # Check database (SQLAlchemy 2.x compatible)
        db.execute(text("SELECT 1"))
        db_status = "healthy"
    except Exception as e:
        db_status = f"unhealthy: {str(e)}"
    
    # Check LLM services
    llm_service = LLMService()
    llm_status = await llm_service.test_connection()
    
    # Check sandbox service
    sandbox_service = SandboxService()
    sandbox_status = "healthy" if sandbox_service.docker_client else "unhealthy"
    
    return {
        "status": "healthy",
        "service": "Orange Sage API",
        "version": "1.0.0",
        "components": {
            "database": db_status,
            "llm_services": llm_status,
            "sandbox_service": sandbox_status
        }
    }


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\projects.py
"""
Project endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.orm import Session
from typing import List, Dict, Any

from app.core.database import get_db
from app.models.project import Project
from app.models.user import User
from app.utils.auth import get_current_user
from app.schemas.project import ProjectCreate, ProjectUpdate, ProjectResponse
 
router = APIRouter()

@router.post("/", response_model=ProjectResponse)
async def create_project(
    data: ProjectCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new project"""
    try:
        project = Project(
            name=data.name,
            description=data.description,
            owner_id=current_user.id
        )
        db.add(project)
        db.commit()
        db.refresh(project)
        return project
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating project: {str(e)}"
        )

@router.get("/")
async def list_projects(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List projects for the current user"""
    projects = db.query(Project).filter(Project.owner_id == current_user.id).all()
    
    # Return projects with is_active flag for frontend compatibility
    return [
        {
            "id": project.id,
            "name": project.name,
            "description": project.description,
            "created_at": project.created_at.isoformat() if project.created_at else None,
            "updated_at": project.updated_at.isoformat() if project.updated_at else None,
            "is_active": True  # Add is_active flag for frontend compatibility
        }
        for project in projects
    ]


@router.get("/{project_id}")
async def get_project(
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific project"""
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    if project.owner_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    return {
        "id": project.id,
        "name": project.name,
        "description": project.description,
        "created_at": project.created_at,
        "updated_at": project.updated_at
    }


@router.put("/{project_id}", response_model=ProjectResponse)
async def update_project(
    project_id: int,
    data: ProjectUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a project (partial)"""
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found")
    if project.owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    try:
        if data.name is not None:
            project.name = data.name
        if data.description is not None:
            project.description = data.description
        db.commit()
        db.refresh(project)
        return project
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error updating project: {str(e)}")


@router.delete("/{project_id}")
async def delete_project(
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a project if it has no targets or scans"""
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found")
    if project.owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    try:
        # Dependency checks
        from app.models.target import Target
        from app.models.scan import Scan
        targets_count = db.query(Target).filter(Target.project_id == project_id).count()
        scans_count = db.query(Scan).filter(Scan.project_id == project_id).count()
        if targets_count > 0 or scans_count > 0:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Cannot delete project with {targets_count} targets and {scans_count} scans"
            )
        db.delete(project)
        db.commit()
        return {"status": "deleted", "project_id": project_id}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error deleting project: {str(e)}")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\reports.py
"""
Report endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, status, Response
from sqlalchemy.orm import Session
from typing import List, Optional
import os

from app.core.database import get_db
from app.models.report import Report, ReportFormat, ReportStatus
from app.models.user import User
from app.services.report_generator import ReportGenerator
from app.utils.auth import get_current_user

router = APIRouter()


@router.get("")
async def get_reports(
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all reports for the current user"""
    try:
        reports = db.query(Report).order_by(Report.created_at.desc()).offset(skip).limit(limit).all()
        
        # Return array directly for frontend compatibility
        return [
            {
                "id": report.id,
                "name": report.name,
                "format": report.format.value,
                "status": report.status.value,
                "scan_id": report.scan_id,
                "created_at": report.created_at.isoformat() if report.created_at else None,
                "generated_at": report.generated_at.isoformat() if report.generated_at else None,
                "download_url": report.download_url,
                "file_size": report.file_size
            }
            for report in reports
        ]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching reports: {str(e)}"
        )


@router.post("/generate")
async def generate_report(
    scan_id: int,
    format: str = "html",
    include_charts: bool = True,
    include_pocs: bool = True,
    branding: str = "Orange Sage",
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Generate a detailed security assessment report for a scan"""
    try:
        from app.models.scan import Scan
        from app.models.finding import Finding
        from datetime import datetime
        
        # Get scan
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )
        
        # Get findings
        findings = db.query(Finding).filter(Finding.scan_id == scan_id).all()
        
        # Create report record
        report = Report(
            name=f"Security Assessment Report - {scan.name}",
            format=ReportFormat.HTML if format.lower() == "html" else ReportFormat.PDF,
            status=ReportStatus.COMPLETED,
            scan_id=scan_id,
            include_charts="true",
            include_pocs="true",
            branding=branding,
            generated_at=datetime.utcnow()
        )
        
        # Generate detailed HTML report
        html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Assessment Report - {scan.name}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; 
               line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.1); }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; text-align: center; }}
        .header h1 {{ font-size: 32px; margin-bottom: 10px; }}
        .header p {{ font-size: 14px; opacity: 0.9; }}
        .summary {{ padding: 30px; background: #f8f9fa; border-bottom: 3px solid #667eea; }}
        .summary-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }}
        .summary-card {{ background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .summary-card h3 {{ font-size: 36px; margin-bottom: 5px; }}
        .summary-card p {{ color: #666; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }}
        .critical {{ color: #dc3545; }}
        .high {{ color: #fd7e14; }}
        .medium {{ color: #ffc107; }}
        .low {{ color: #28a745; }}
        .content {{ padding: 40px; }}
        .section {{ margin-bottom: 40px; }}
        .section h2 {{ color: #667eea; font-size: 24px; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #e9ecef; }}
        .finding {{ background: #f8f9fa; padding: 25px; margin-bottom: 20px; border-left: 4px solid #667eea; border-radius: 4px; }}
        .finding.critical {{ border-left-color: #dc3545; background: #fff5f5; }}
        .finding.high {{ border-left-color: #fd7e14; background: #fff8f0; }}
        .finding.medium {{ border-left-color: #ffc107; background: #fffbf0; }}
        .finding.low {{ border-left-color: #28a745; background: #f0fff4; }}
        .finding-header {{ display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px; }}
        .finding-title {{ font-size: 20px; font-weight: 600; color: #2d3748; }}
        .severity-badge {{ padding: 6px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-transform: uppercase; }}
        .severity-badge.critical {{ background: #dc3545; color: white; }}
        .severity-badge.high {{ background: #fd7e14; color: white; }}
        .severity-badge.medium {{ background: #ffc107; color: #000; }}
        .severity-badge.low {{ background: #28a745; color: white; }}
        .finding-meta {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; 
                         padding: 15px; background: white; border-radius: 4px; }}
        .meta-item {{ }}
        .meta-label {{ font-weight: 600; color: #667eea; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; }}
        .meta-value {{ color: #555; margin-top: 4px; font-family: 'Courier New', monospace; font-size: 13px; }}
        .finding-description {{ margin: 15px 0; line-height: 1.8; color: #4a5568; }}
        .remediation {{ background: #e3f2fd; padding: 15px; border-radius: 4px; margin-top: 15px; }}
        .remediation h4 {{ color: #1976d2; margin-bottom: 10px; font-size: 16px; }}
        .references {{ margin-top: 15px; }}
        .references h4 {{ color: #667eea; margin-bottom: 8px; font-size: 14px; }}
        .references ul {{ list-style: none; padding-left: 0; }}
        .references li {{ padding: 4px 0; color: #666; }}
        .references a {{ color: #667eea; text-decoration: none; }}
        .references a:hover {{ text-decoration: underline; }}
        .footer {{ background: #2d3748; color: white; padding: 20px 40px; text-align: center; font-size: 14px; }}
        .scan-info {{ background: #e3f2fd; padding: 20px; border-radius: 4px; margin-bottom: 20px; }}
        .scan-info-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }}
        .info-item {{ }}
        .info-label {{ font-weight: 600; color: #1976d2; font-size: 12px; text-transform: uppercase; }}
        .info-value {{ color: #444; margin-top: 4px; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí Security Assessment Report</h1>
            <p>Generated by {branding} | {datetime.now().strftime('%B %d, %Y at %I:%M %p')}</p>
        </div>
        
        <div class="summary">
            <h2 style="color: #2d3748; margin-bottom: 10px;">Executive Summary</h2>
            <p>This report contains the results of a comprehensive security assessment performed on the target application.</p>
            <div class="summary-grid">
                <div class="summary-card">
                    <h3>{len(findings)}</h3>
                    <p>Total Findings</p>
                </div>
                <div class="summary-card">
                    <h3 class="critical">{len([f for f in findings if f.severity.value == 'critical'])}</h3>
                    <p>Critical</p>
                </div>
                <div class="summary-card">
                    <h3 class="high">{len([f for f in findings if f.severity.value == 'high'])}</h3>
                    <p>High</p>
                </div>
                <div class="summary-card">
                    <h3 class="medium">{len([f for f in findings if f.severity.value == 'medium'])}</h3>
                    <p>Medium</p>
                </div>
                <div class="summary-card">
                    <h3 class="low">{len([f for f in findings if f.severity.value == 'low'])}</h3>
                    <p>Low</p>
                </div>
            </div>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>üìã Scan Information</h2>
                <div class="scan-info">
                    <div class="scan-info-grid">
                        <div class="info-item">
                            <div class="info-label">Scan Name</div>
                            <div class="info-value">{scan.name}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Target</div>
                            <div class="info-value">{scan.target.value if scan.target else 'N/A'}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Scan Status</div>
                            <div class="info-value">{scan.status.value.upper()}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Started</div>
                            <div class="info-value">{scan.started_at.strftime('%Y-%m-%d %H:%M') if scan.started_at else 'N/A'}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Completed</div>
                            <div class="info-value">{scan.finished_at.strftime('%Y-%m-%d %H:%M') if scan.finished_at else 'N/A'}</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>üîç Detailed Findings</h2>
                <p style="margin-bottom: 20px; color: #666;">The following security issues were identified during the assessment. Each finding includes a detailed description, affected components, and remediation guidance.</p>
"""
        
        # Group findings by severity
        findings_by_severity = {
            'critical': [f for f in findings if f.severity.value == 'critical'],
            'high': [f for f in findings if f.severity.value == 'high'],
            'medium': [f for f in findings if f.severity.value == 'medium'],
            'low': [f for f in findings if f.severity.value == 'low']
        }
        
        # Add findings to report
        for severity, severity_findings in findings_by_severity.items():
            if severity_findings:
                for idx, finding in enumerate(severity_findings, 1):
                    html_content += f"""
                <div class="finding {severity}">
                    <div class="finding-header">
                        <div class="finding-title">#{idx}. {finding.title}</div>
                        <span class="severity-badge {severity}">{severity.upper()}</span>
                    </div>
                    
                    <div class="finding-meta">
                        <div class="meta-item">
                            <div class="meta-label">Type</div>
                            <div class="meta-value">{finding.vulnerability_type or 'N/A'}</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-label">Endpoint</div>
                            <div class="meta-value">{finding.endpoint or 'N/A'}</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-label">Parameter</div>
                            <div class="meta-value">{finding.parameter or 'N/A'}</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-label">Method</div>
                            <div class="meta-value">{finding.method or 'N/A'}</div>
                        </div>
                    </div>
                    
                    <div class="finding-description">
                        <strong>Description:</strong><br>
                        {finding.description or 'No description provided.'}
                    </div>
                    
                    <div class="remediation">
                        <h4>üõ†Ô∏è Remediation</h4>
                        <p>{finding.remediation_text or 'Please consult with security experts for remediation guidance.'}</p>
                    </div>
                    
                    {f'''<div class="references">
                        <h4>üìö References</h4>
                        <ul>
                            {''.join([f'<li><strong>{k.upper()}:</strong> {v}</li>' for k, v in (finding.references or {}).items()])}
                        </ul>
                    </div>''' if finding.references else ''}
                </div>
"""
        
        html_content += """
            </div>
        </div>
        
        <div class="footer">
            <p>This report was generated automatically by Orange Sage Security Platform.</p>
            <p style="margin-top: 10px; font-size: 12px; opacity: 0.8;">¬© 2025 Orange Sage. All rights reserved.</p>
        </div>
    </div>
</body>
</html>
"""
        
        # Save report content
        import base64
        report.storage_key = f"report_{report.id}_{datetime.now().timestamp()}.html"
        report.download_url = f"/api/v1/reports/{report.id}/download"
        report.file_size = len(html_content.encode('utf-8'))
        report.report_metadata = {
            "html_content": base64.b64encode(html_content.encode('utf-8')).decode('utf-8'),
            "total_findings": len(findings),
            "findings_by_severity": {k: len(v) for k, v in findings_by_severity.items()}
        }
        
        db.add(report)
        db.commit()
        db.refresh(report)
        
        return {
            "id": report.id,
            "name": report.name,
            "status": report.status.value,
            "format": report.format.value,
            "scan_id": scan_id,
            "download_url": report.download_url,
            "file_size": report.file_size,
            "generated_at": report.generated_at.isoformat() if report.generated_at else None,
            "preview": html_content[:500] + "..." if len(html_content) > 500 else html_content
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating report: {str(e)}"
        )


@router.get("/{report_id}/status")
async def get_report_status(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get report generation status"""
    try:
        report_generator = ReportGenerator()
        status_info = await report_generator.get_report_status(report_id, db)
        
        return status_info
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting report status: {str(e)}"
        )


@router.get("/{report_id}/download")
async def download_report(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Download a generated report"""
    try:
        import base64
        from app.models.scan import Scan
        
        # Get report
        report = db.query(Report).filter(Report.id == report_id).first()
        if not report:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Report not found"
            )
        
        # Get HTML content from metadata
        if not report.report_metadata or 'html_content' not in report.report_metadata:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Report content not found"
            )
        
        # Decode HTML content
        html_content = base64.b64decode(report.report_metadata['html_content']).decode('utf-8')
        
        # Determine filename
        scan = db.query(Scan).filter(Scan.id == report.scan_id).first()
        filename = f"security_report_{scan.name if scan else report.id}.html".replace(" ", "_")
        
        # Return HTML file
        return Response(
            content=html_content,
            media_type="text/html",
            headers={
                "Content-Disposition": f"attachment; filename={filename}",
                "Content-Length": str(len(html_content))
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error downloading report: {str(e)}"
        )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\scans.py
"""
Scan endpoints for Orange Sage
"""

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Dict, Any
from datetime import datetime

from app.core.database import get_db
from app.models.scan import Scan, ScanStatus
from app.models.user import User
from app.schemas.scan import ScanCreate, ScanResponse, ScanStatusResponse
from app.services.agent_manager import AgentManager
from app.utils.auth import get_current_user

router = APIRouter()


@router.post("/", response_model=ScanResponse)
async def create_scan(
    scan_data: ScanCreate,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new security scan"""
    try:
        # Create scan record
        scan = Scan(
            name=scan_data.name,
            description=scan_data.description,
            project_id=scan_data.project_id,
            target_id=scan_data.target_id,
            created_by=current_user.id,
            scan_config=scan_data.scan_config,
            agent_config=scan_data.agent_config
        )
        
        db.add(scan)
        db.commit()
        db.refresh(scan)
        
        # Start scan in background
        agent_manager = AgentManager()
        background_tasks.add_task(
            agent_manager.start_scan,
            db,
            scan.id,
            scan_data.scan_config
        )
        
        return ScanResponse(
            id=scan.id,
            name=scan.name,
            description=scan.description,
            status=scan.status.value,
            project_id=scan.project_id,
            target_id=scan.target_id,
            created_by=scan.created_by,
            created_at=scan.created_at,
            started_at=scan.started_at,
            finished_at=scan.finished_at
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating scan: {str(e)}"
        )


@router.get("/{scan_id}", response_model=ScanStatusResponse)
async def get_scan_status(
    scan_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get scan status and progress"""
    try:
        # Get scan
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )
        
        # Check if user has access to this scan
        if scan.created_by != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
        
        # Get agent manager and scan status
        agent_manager = AgentManager()
        status_info = await agent_manager.get_scan_status(scan_id, db)
        
        return ScanStatusResponse(
            scan_id=scan_id,
            name=scan.name,
            status=scan.status.value,
            target=scan.target.value if scan.target else None,
            agents_count=status_info.get("agents_count", 0),
            findings_count=status_info.get("findings_count", 0),
            started_at=scan.started_at,
            finished_at=scan.finished_at,
            summary=scan.summary,
            error=scan.error_message
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting scan status: {str(e)}"
        )


@router.get("/{scan_id}/agents")
async def get_scan_agents(
    scan_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get agents for a scan"""
    try:
        # Get scan
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )
        
        # Check if user has access to this scan
        if scan.created_by != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
        
        # Get agents
        agent_manager = AgentManager()
        agents = await agent_manager.get_scan_agents(scan_id, db)
        
        return {"agents": agents}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting scan agents: {str(e)}"
        )


@router.post("/{scan_id}/cancel")
async def cancel_scan(
    scan_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Cancel a running scan"""
    try:
        # Get scan
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Scan not found"
            )
        
        # Check if user has access to this scan
        if scan.created_by != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
        
        # Cancel scan
        agent_manager = AgentManager()
        result = await agent_manager.cancel_scan(scan_id, db)
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error cancelling scan: {str(e)}"
        )


@router.get("/")
async def list_scans(
    project_id: int = None,
    status: str = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List scans for the current user"""
    try:
        # Build query
        query = db.query(Scan).filter(Scan.created_by == current_user.id)
        
        if project_id:
            query = query.filter(Scan.project_id == project_id)
        
        if status:
            query = query.filter(Scan.status == ScanStatus(status))
        
        scans = query.order_by(Scan.created_at.desc()).all()
        
        # Return array directly for frontend compatibility
        return [
            {
                "id": scan.id,
                "name": scan.name,
                "status": scan.status.value,
                "project_id": scan.project_id,
                "target_id": scan.target_id,
                "target": scan.target.value if scan.target else "",
                "created_at": scan.created_at.isoformat() if scan.created_at else None,
                "started_at": scan.started_at.isoformat() if scan.started_at else None,
                "finished_at": scan.finished_at.isoformat() if scan.finished_at else None,
                "project_name": scan.project.name if scan.project else ""
            }
            for scan in scans
        ]
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing scans: {str(e)}"
        )


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\api\v1\endpoints\targets.py
"""
Target endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.models.target import Target
from app.models.project import Project
from app.models.user import User
from app.utils.auth import get_current_user
from app.schemas.target import TargetCreate, TargetUpdate, TargetResponse

router = APIRouter()


@router.post("/", response_model=TargetResponse)
async def create_target(
    data: TargetCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new target"""
    try:
        # Verify project exists and user has access
        project = db.query(Project).filter(Project.id == data.project_id).first()
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found"
            )
        if project.owner_id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied to this project"
            )

        target = Target(
            name=data.name,
            type=data.type,
            value=data.value,
            description=data.description,
            project_id=data.project_id,
            config=data.config
        )
        db.add(target)
        db.commit()
        db.refresh(target)
        return target
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating target: {str(e)}"
        )


@router.get("/")
async def list_targets(
    project_id: int = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List targets"""
    query = db.query(Target)
    
    if project_id:
        query = query.filter(Target.project_id == project_id)
    
    targets = query.all()
    
    return {
        "targets": [
            {
                "id": target.id,
                "name": target.name,
                "type": target.type,
                "value": target.value,
                "description": target.description,
                "project_id": target.project_id,
                "created_at": target.created_at
            }
            for target in targets
        ]
    }


@router.get("/{target_id}", response_model=TargetResponse)
async def get_target(
    target_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific target"""
    target = db.query(Target).filter(Target.id == target_id).first()
    if not target:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Target not found"
        )
    # Ownership check through project relationship
    project = db.query(Project).filter(Project.id == target.project_id).first()
    if not project or project.owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    return target


@router.put("/{target_id}", response_model=TargetResponse)
async def update_target(
    target_id: int,
    data: TargetUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a target (partial)"""
    target = db.query(Target).filter(Target.id == target_id).first()
    if not target:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Target not found")
    project = db.query(Project).filter(Project.id == target.project_id).first()
    if not project or project.owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    try:
        if data.name is not None:
            target.name = data.name
        if data.type is not None:
            target.type = data.type
        if data.value is not None:
            target.value = data.value
        if data.description is not None:
            target.description = data.description
        if data.config is not None:
            target.config = data.config
        db.commit()
        db.refresh(target)
        return target
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error updating target: {str(e)}")


@router.delete("/{target_id}")
async def delete_target(
    target_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a target if no scans exist for it"""
    target = db.query(Target).filter(Target.id == target_id).first()
    if not target:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Target not found")
    project = db.query(Project).filter(Project.id == target.project_id).first()
    if not project or project.owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    try:
        from app.models.scan import Scan
        scans_count = db.query(Scan).filter(Scan.target_id == target_id).count()
        if scans_count > 0:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Cannot delete target with {scans_count} associated scans"
            )
        db.delete(target)
        db.commit()
        return {"status": "deleted", "target_id": target_id}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error deleting target: {str(e)}")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\core\config.py
"""
Configuration settings for Orange Sage Backend
"""

import os
from typing import List, Optional
from pydantic_settings import BaseSettings
from pydantic import validator


class Settings(BaseSettings):
    """Application settings"""
    
    # App settings
    APP_NAME: str = "Orange Sage API"
    VERSION: str = "1.0.0"
    DEBUG: bool = False
    HOST: str = "0.0.0.0"
    PORT: int = int(os.getenv("PORT", "8080"))
    
    # Security
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 180
    ALGORITHM: str = "HS256"
    
    # CORS
    ALLOWED_ORIGINS: List[str] = ["*"]  # Allow all origins for Cloud Run
    ALLOWED_HOSTS: List[str] = ["*"]  # Allow all hosts for Cloud Run
    
    # Database
    DATABASE_URL: str = "sqlite:///./orange_sage.db"
    
    # Redis
    REDIS_URL: str = "redis://localhost:6379"
    
    # LLM Configuration
    OPENAI_API_KEY: str = ""
    GEMINI_API_KEY: str = ""
    DEFAULT_LLM_MODEL: str = "gpt-4o-mini"
    FALLBACK_LLM_MODEL: str = "gemini-2.0-flash-lite"
    
    # Agent Configuration
    MAX_AGENTS_PER_SCAN: int = 10
    AGENT_TIMEOUT_MINUTES: int = 30
    SANDBOX_TIMEOUT_MINUTES: int = 60
    
    # Docker/Sandbox
    DOCKER_NETWORK: str = "orange_sage_network"
    SANDBOX_IMAGE: str = "orange_sage/sandbox:latest"
    SANDBOX_MEMORY_LIMIT: str = "2g"
    SANDBOX_CPU_LIMIT: str = "1.0"
    
    # Storage
    UPLOAD_DIR: str = "./uploads"
    REPORTS_DIR: str = "./reports"
    MAX_FILE_SIZE: int = 100 * 1024 * 1024  # 100MB
    
    # Monitoring
    ENABLE_METRICS: bool = True
    METRICS_PORT: int = 9090
    
    # Logging
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    
    @validator("ALLOWED_ORIGINS", pre=True)
    def assemble_cors_origins(cls, v):
        if isinstance(v, str):
            return [i.strip() for i in v.split(",")]
        return v
    
    @validator("ALLOWED_HOSTS", pre=True)
    def assemble_allowed_hosts(cls, v):
        if isinstance(v, str):
            return [i.strip() for i in v.split(",")]
        return v
    
    class Config:
        env_file = ".env"
        case_sensitive = True


# Create settings instance
settings = Settings()


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\core\config_local.py
"""
Local configuration for Orange Sage (without Docker)
"""

import os
from typing import List, Union
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import AnyHttpUrl, field_validator

class LocalSettings(BaseSettings):
    PROJECT_NAME: str = "Orange Sage"
    API_V1_STR: str = "/api/v1"
    SECRET_KEY: str = "your-super-secret-key-for-local-development"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days

    # Database - Using SQLite for local development
    DATABASE_URL: str = "sqlite:///./orange_sage.db"
    ASYNC_DATABASE_URL: str = "sqlite+aiosqlite:///./orange_sage.db"

    # CORS
    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = [
        "http://localhost:5173",
        "http://localhost:3000",
        "http://127.0.0.1:5173",
        "http://127.0.0.1:3000"
    ]

    @field_validator("BACKEND_CORS_ORIGINS", mode="before")
    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:
        if isinstance(v, str):
            return [i.strip() for i in v.split(",")]
        elif isinstance(v, List):
            return v
        raise ValueError("BACKEND_CORS_ORIGINS must be a string or list of strings")

    # LLM - Use your API keys here
    OPENAI_API_KEY: str = "sk-your-openai-key-here"
    GEMINI_API_KEY: str = "AIzaSyC-your-gemini-key-here"
    LLM_MODEL: str = "gpt-4o"

    # Local file storage (no S3/MinIO needed)
    UPLOAD_DIR: str = "./uploads"
    REPORTS_DIR: str = "./reports"
    
    # Create directories if they don't exist
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        os.makedirs(self.UPLOAD_DIR, exist_ok=True)
        os.makedirs(self.REPORTS_DIR, exist_ok=True)

    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

settings = LocalSettings()


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\core\database.py
"""
Database configuration for Orange Sage
"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

# Create database engine
engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create base class for models
Base = declarative_base()


def get_db():
    """Get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def init_db():
    """Initialize database tables"""
    # Import all models to ensure they are registered
    from app.models.user import User
    from app.models.project import Project
    from app.models.target import Target
    from app.models.scan import Scan
    from app.models.finding import Finding
    from app.models.agent import Agent
    from app.models.report import Report
    
    # Create all tables
    Base.metadata.create_all(bind=engine)


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\core\database_local.py
"""
Local database configuration using SQLite
"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker as async_sessionmaker

from app.core.config_local import settings

# Synchronous database
engine = create_engine(settings.DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Asynchronous database
async_engine = create_async_engine(settings.ASYNC_DATABASE_URL, echo=True)
AsyncSessionLocal = async_sessionmaker(async_engine, class_=AsyncSession, expire_on_commit=False)

def get_db():
    """Get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_async_db():
    """Get async database session"""
    async with AsyncSessionLocal() as session:
        yield session

# Create all tables
def create_tables():
    """Create all database tables"""
    Base.metadata.create_all(bind=engine)

# Initialize database
def init_db():
    """Initialize database with tables"""
    create_tables()
    print("‚úÖ Database initialized successfully")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\core\logging_config.py
"""
Logging configuration for Orange Sage
"""

import logging
import sys
from app.core.config import settings


def setup_logging():
    """Setup application logging"""
    
    # Create formatter
    formatter = logging.Formatter(settings.LOG_FORMAT)
    
    # Setup root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, settings.LOG_LEVEL.upper()))
    
    # Remove existing handlers
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # Create console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(getattr(logging, settings.LOG_LEVEL.upper()))
    console_handler.setFormatter(formatter)
    
    # Add handler to root logger
    root_logger.addHandler(console_handler)
    
    # Setup specific loggers
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("fastapi").setLevel(logging.INFO)
    logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)
    
    # Log startup message
    logger = logging.getLogger(__name__)
    logger.info("Logging configured successfully")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\agent.py
"""
Agent model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON, Enum
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class AgentStatus(str, enum.Enum):
    """Agent status enumeration"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class Agent(Base):
    """Agent model for AI agents"""
    __tablename__ = "agents"
    
    id = Column(Integer, primary_key=True, index=True)
    agent_id = Column(String(100), unique=True, nullable=False)  # UUID
    name = Column(String(255), nullable=False)
    task = Column(Text, nullable=False)
    status = Column(Enum(AgentStatus), default=AgentStatus.PENDING)
    scan_id = Column(Integer, ForeignKey("scans.id"), nullable=False)
    parent_agent_id = Column(String(100), nullable=True)
    
    # Agent configuration
    agent_type = Column(String(100), nullable=False)  # OrangeSageAgent, etc.
    prompt_modules = Column(JSON, nullable=True)
    llm_config = Column(JSON, nullable=True)
    
    # Execution details
    iteration = Column(Integer, default=0)
    max_iterations = Column(Integer, default=200)
    sandbox_id = Column(String(100), nullable=True)
    
    # Timing
    started_at = Column(DateTime, nullable=True)
    finished_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Results
    final_result = Column(JSON, nullable=True)
    error_message = Column(Text, nullable=True)
    execution_summary = Column(JSON, nullable=True)
    
    # Relationships
    scan = relationship("Scan", back_populates="agents")
    
    def __repr__(self):
        return f"<Agent(id={self.id}, agent_id={self.agent_id}, name={self.name})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\finding.py
"""
Finding model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON, Enum
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class SeverityLevel(str, enum.Enum):
    """Severity level enumeration"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class FindingStatus(str, enum.Enum):
    """Finding status enumeration"""
    OPEN = "open"
    TRIAGED = "triaged"
    FALSE_POSITIVE = "false_positive"
    RESOLVED = "resolved"


class Finding(Base):
    """Finding model for security vulnerabilities"""
    __tablename__ = "findings"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=False)
    severity = Column(Enum(SeverityLevel), nullable=False)
    status = Column(Enum(FindingStatus), default=FindingStatus.OPEN)
    scan_id = Column(Integer, ForeignKey("scans.id"), nullable=False)
    
    # Technical details
    vulnerability_type = Column(String(100), nullable=True)  # SQLi, XSS, etc.
    endpoint = Column(String(500), nullable=True)
    parameter = Column(String(255), nullable=True)
    method = Column(String(10), nullable=True)  # GET, POST, etc.
    
    # Evidence
    request_sample = Column(Text, nullable=True)
    response_sample = Column(Text, nullable=True)
    poc_artifact_key = Column(String(500), nullable=True)  # S3 key for PoC
    
    # Remediation
    remediation_text = Column(Text, nullable=True)
    references = Column(JSON, nullable=True)  # CWE, OWASP links
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by_agent = Column(String(100), nullable=True)
    
    # Relationships
    scan = relationship("Scan", back_populates="findings")
    
    def __repr__(self):
        return f"<Finding(id={self.id}, title={self.title}, severity={self.severity})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\project.py
"""
Project model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship
from app.core.database import Base


class Project(Base):
    """Project model"""
    __tablename__ = "projects"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    owner = relationship("User", back_populates="projects")
    targets = relationship("Target", back_populates="project")
    scans = relationship("Scan", back_populates="project")
    
    def __repr__(self):
        return f"<Project(id={self.id}, name={self.name})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\report.py
"""
Report model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON, Enum
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class ReportFormat(str, enum.Enum):
    """Report format enumeration"""
    PDF = "pdf"
    DOCX = "docx"
    HTML = "html"


class ReportStatus(str, enum.Enum):
    """Report status enumeration"""
    PENDING = "pending"
    GENERATING = "generating"
    COMPLETED = "completed"
    FAILED = "failed"


class Report(Base):
    """Report model for generated reports"""
    __tablename__ = "reports"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    format = Column(Enum(ReportFormat), nullable=False)
    status = Column(Enum(ReportStatus), default=ReportStatus.PENDING)
    scan_id = Column(Integer, ForeignKey("scans.id"), nullable=False)
    
    # Report configuration
    include_charts = Column(String(10), default="true")
    include_pocs = Column(String(10), default="true")
    branding = Column(String(100), nullable=True)
    custom_template = Column(String(255), nullable=True)
    
    # File storage
    storage_key = Column(String(500), nullable=True)  # S3 key
    file_size = Column(Integer, nullable=True)
    download_url = Column(String(1000), nullable=True)
    expires_at = Column(DateTime, nullable=True)
    
    # Timing
    generated_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Metadata
    generation_error = Column(Text, nullable=True)
    report_metadata = Column(JSON, nullable=True)
    
    # Relationships
    scan = relationship("Scan", back_populates="reports")
    
    def __repr__(self):
        return f"<Report(id={self.id}, name={self.name}, format={self.format})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\scan.py
"""
Scan model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON, Enum
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum


class ScanStatus(str, enum.Enum):
    """Scan status enumeration"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class Scan(Base):
    """Scan model for security assessments"""
    __tablename__ = "scans"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    status = Column(Enum(ScanStatus), default=ScanStatus.PENDING)
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=False)
    target_id = Column(Integer, ForeignKey("targets.id"), nullable=False)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # Scan configuration
    scan_config = Column(JSON, nullable=True)
    agent_config = Column(JSON, nullable=True)
    
    # Timing
    started_at = Column(DateTime, nullable=True)
    finished_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Results
    summary = Column(JSON, nullable=True)
    error_message = Column(Text, nullable=True)
    
    # Relationships
    project = relationship("Project", back_populates="scans")
    target = relationship("Target", back_populates="scans")
    created_by_user = relationship("User", back_populates="scans")
    findings = relationship("Finding", back_populates="scan")
    agents = relationship("Agent", back_populates="scan")
    reports = relationship("Report", back_populates="scan")
    
    def __repr__(self):
        return f"<Scan(id={self.id}, name={self.name}, status={self.status})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\target.py
"""
Target model for Orange Sage
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, JSON
from sqlalchemy.orm import relationship
from app.core.database import Base


class Target(Base):
    """Target model for security assessment"""
    __tablename__ = "targets"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    type = Column(String(50), nullable=False)  # url, repository, upload
    value = Column(Text, nullable=False)  # URL, repo path, or file path
    description = Column(Text, nullable=True)
    project_id = Column(Integer, ForeignKey("projects.id"), nullable=False)
    config = Column(JSON, nullable=True)  # Additional configuration
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    project = relationship("Project", back_populates="targets")
    scans = relationship("Scan", back_populates="target")
    
    def __repr__(self):
        return f"<Target(id={self.id}, name={self.name}, type={self.type})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\models\user.py
"""
User model for Orange Sage
"""

from datetime import datetime
from typing import Optional
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.orm import relationship
from app.core.database import Base


class User(Base):
    """User model"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(255), nullable=True)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)
    
    # Relationships
    projects = relationship("Project", back_populates="owner")
    scans = relationship("Scan", back_populates="created_by_user")
    
    def __repr__(self):
        return f"<User(id={self.id}, email={self.email})>"


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\schemas\auth.py
"""
Authentication schemas
"""

from pydantic import BaseModel, EmailStr, validator, Field
from datetime import datetime
from typing import Optional


class UserCreate(BaseModel):
    """User creation schema"""
    email: EmailStr
    username: str
    password: str = Field(..., min_length=6)
    full_name: Optional[str] = None


class UserLogin(BaseModel):
    """User login schema"""
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    """User response schema"""
    id: int
    email: str
    username: str
    full_name: Optional[str]
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True


class Token(BaseModel):
    """Token response schema"""
    access_token: str
    token_type: str
    expires_in: int


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\schemas\project.py
# backend/app/schemas/project.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ProjectCreate(BaseModel):
    """Project creation schema"""
    name: str
    description: Optional[str] = None

class ProjectUpdate(BaseModel):
    """Project update schema (partial)"""
    name: Optional[str] = None
    description: Optional[str] = None

class ProjectResponse(BaseModel):
    """Project response schema"""
    id: int
    name: str
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

# File: C:\Users\user\Desktop\Orange-Sage\backend\app\schemas\scan.py
"""
Scan schemas
"""

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict, Any


class ScanCreate(BaseModel):
    """Scan creation schema"""
    name: str
    description: Optional[str] = None
    project_id: int
    target_id: int
    scan_config: Optional[Dict[str, Any]] = None
    agent_config: Optional[Dict[str, Any]] = None


class ScanResponse(BaseModel):
    """Scan response schema"""
    id: int
    name: str
    description: Optional[str]
    status: str
    project_id: int
    target_id: int
    created_by: int
    created_at: datetime
    started_at: Optional[datetime]
    finished_at: Optional[datetime]
    
    class Config:
        from_attributes = True


class ScanStatusResponse(BaseModel):
    """Scan status response schema"""
    scan_id: int
    name: str
    status: str
    target: Optional[str]
    agents_count: int
    findings_count: int
    started_at: Optional[datetime]
    finished_at: Optional[datetime]
    summary: Optional[Dict[str, Any]]
    error: Optional[str]


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\schemas\target.py
"""
Target schemas
"""

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict, Any


class TargetCreate(BaseModel):
    """Target creation schema"""
    name: str
    type: str  # url, repository, upload
    value: str  # URL, repo path, or file path
    description: Optional[str] = None
    project_id: int
    config: Optional[Dict[str, Any]] = None


class TargetUpdate(BaseModel):
    """Target update schema (partial)"""
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[str] = None
    description: Optional[str] = None
    config: Optional[Dict[str, Any]] = None


class TargetResponse(BaseModel):
    """Target response schema"""
    id: int
    name: str
    type: str
    value: str
    description: Optional[str]
    project_id: int
    config: Optional[Dict[str, Any]]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True




# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\advanced_report_generator.py
"""
Advanced Report Generator for Orange Sage
Generates comprehensive PDF reports with detailed analysis
"""

import asyncio
import base64
import io
import json
import logging
import os
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path

# PDF generation libraries
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak, Image
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT, TA_JUSTIFY
from reportlab.graphics.shapes import Drawing, Rect, String
from reportlab.graphics.charts.piecharts import Pie
from reportlab.graphics.charts.barcharts import VerticalBarChart
from reportlab.graphics import renderPDF

# HTML to PDF conversion
try:
    import weasyprint
    WEASYPRINT_AVAILABLE = True
except (ImportError, OSError) as e:
    # WeasyPrint requires GTK+ libraries which are not available by default on Windows
    # The application will work fine without it, using ReportLab for PDF generation instead
    WEASYPRINT_AVAILABLE = False
    weasyprint = None
    # Only log at debug level to avoid alarming users
    logger_temp = logging.getLogger(__name__)
    logger_temp.debug(f"WeasyPrint not available: {e}")

from jinja2 import Template

logger = logging.getLogger(__name__)


class AdvancedReportGenerator:
    """Advanced report generator with comprehensive analysis"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_custom_styles(self):
        """Setup custom styles for the report"""
        # Title style
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#2E86AB')
        ))
        
        # Section header style
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            spaceAfter=12,
            spaceBefore=20,
            textColor=colors.HexColor('#A23B72')
        ))
        
        # Finding title style
        self.styles.add(ParagraphStyle(
            name='FindingTitle',
            parent=self.styles['Heading3'],
            fontSize=14,
            spaceAfter=8,
            textColor=colors.HexColor('#F18F01')
        ))
        
        # Critical severity style
        self.styles.add(ParagraphStyle(
            name='CriticalSeverity',
            parent=self.styles['Normal'],
            fontSize=12,
            textColor=colors.HexColor('#D32F2F'),
            backColor=colors.HexColor('#FFEBEE')
        ))
        
        # High severity style
        self.styles.add(ParagraphStyle(
            name='HighSeverity',
            parent=self.styles['Normal'],
            fontSize=12,
            textColor=colors.HexColor('#F57C00'),
            backColor=colors.HexColor('#FFF3E0')
        ))
        
        # Medium severity style
        self.styles.add(ParagraphStyle(
            name='MediumSeverity',
            parent=self.styles['Normal'],
            fontSize=12,
            textColor=colors.HexColor('#FBC02D'),
            backColor=colors.HexColor('#FFFDE7')
        ))
        
        # Low severity style
        self.styles.add(ParagraphStyle(
            name='LowSeverity',
            parent=self.styles['Normal'],
            fontSize=12,
            textColor=colors.HexColor('#388E3C'),
            backColor=colors.HexColor('#E8F5E8')
        ))
    
    async def generate_comprehensive_report(
        self,
        scan_data: Dict[str, Any],
        findings: List[Dict[str, Any]],
        target_info: Dict[str, Any],
        branding: Optional[Dict[str, Any]] = None
    ) -> bytes:
        """Generate comprehensive PDF report"""
        try:
            # Create PDF document
            buffer = io.BytesIO()
            doc = SimpleDocTemplate(
                buffer,
                pagesize=A4,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=18
            )
            
            # Build report content
            story = []
            
            # Cover page
            story.extend(self._create_cover_page(scan_data, target_info, branding))
            story.append(PageBreak())
            
            # Executive summary
            story.extend(self._create_executive_summary(scan_data, findings))
            story.append(PageBreak())
            
            # Methodology
            story.extend(self._create_methodology_section())
            story.append(PageBreak())
            
            # Detailed findings
            story.extend(self._create_findings_section(findings))
            story.append(PageBreak())
            
            # Risk assessment
            story.extend(self._create_risk_assessment_section(findings))
            story.append(PageBreak())
            
            # Recommendations
            story.extend(self._create_recommendations_section(findings))
            story.append(PageBreak())
            
            # Technical details
            story.extend(self._create_technical_details_section(scan_data, findings))
            story.append(PageBreak())
            
            # Appendix
            story.extend(self._create_appendix_section(scan_data, findings))
            
            # Build PDF
            doc.build(story)
            
            # Get PDF bytes
            pdf_bytes = buffer.getvalue()
            buffer.close()
            
            logger.info(f"Generated comprehensive report with {len(findings)} findings")
            return pdf_bytes
            
        except Exception as e:
            logger.error(f"Error generating report: {e}")
            raise
    
    def _create_cover_page(
        self,
        scan_data: Dict[str, Any],
        target_info: Dict[str, Any],
        branding: Optional[Dict[str, Any]] = None
    ) -> List:
        """Create cover page"""
        story = []
        
        # Title
        story.append(Paragraph("Orange Sage Security Assessment Report", self.styles['CustomTitle']))
        story.append(Spacer(1, 20))
        
        # Target information
        story.append(Paragraph("Target Information", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        target_table_data = [
            ['Target:', target_info.get('url', target_info.get('hostname', 'N/A'))],
            ['Scan Date:', scan_data.get('created_at', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))],
            ['Scan ID:', scan_data.get('id', 'N/A')],
            ['Scan Type:', scan_data.get('scan_type', 'Comprehensive Security Assessment')],
            ['Status:', scan_data.get('status', 'Completed')]
        ]
        
        target_table = Table(target_table_data, colWidths=[2*inch, 4*inch])
        target_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F5F5F5')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(target_table)
        story.append(Spacer(1, 30))
        
        # Confidentiality notice
        story.append(Paragraph(
            "CONFIDENTIAL - This report contains sensitive security information and should be handled with appropriate care.",
            self.styles['Normal']
        ))
        
        return story
    
    def _create_executive_summary(
        self,
        scan_data: Dict[str, Any],
        findings: List[Dict[str, Any]]
    ) -> List:
        """Create executive summary section"""
        story = []
        
        story.append(Paragraph("Executive Summary", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        # Calculate statistics
        total_findings = len(findings)
        critical_count = len([f for f in findings if f.get('severity') == 'critical'])
        high_count = len([f for f in findings if f.get('severity') == 'high'])
        medium_count = len([f for f in findings if f.get('severity') == 'medium'])
        low_count = len([f for f in findings if f.get('severity') == 'low'])
        
        # Risk score calculation
        risk_score = (critical_count * 10 + high_count * 7 + medium_count * 4 + low_count * 1)
        risk_score = min(risk_score, 100)
        
        # Summary text
        summary_text = f"""
        This security assessment was conducted on {scan_data.get('target', 'the target system')} 
        using Orange Sage's AI-powered penetration testing capabilities. The assessment identified 
        {total_findings} security findings across various categories.
        
        <b>Key Statistics:</b><br/>
        ‚Ä¢ Total Findings: {total_findings}<br/>
        ‚Ä¢ Critical: {critical_count}<br/>
        ‚Ä¢ High: {high_count}<br/>
        ‚Ä¢ Medium: {medium_count}<br/>
        ‚Ä¢ Low: {low_count}<br/>
        ‚Ä¢ Overall Risk Score: {risk_score}/100
        """
        
        story.append(Paragraph(summary_text, self.styles['Normal']))
        story.append(Spacer(1, 20))
        
        # Risk level
        if risk_score >= 80:
            risk_level = "CRITICAL"
            risk_color = colors.HexColor('#D32F2F')
        elif risk_score >= 60:
            risk_level = "HIGH"
            risk_color = colors.HexColor('#F57C00')
        elif risk_score >= 40:
            risk_level = "MEDIUM"
            risk_color = colors.HexColor('#FBC02D')
        else:
            risk_level = "LOW"
            risk_color = colors.HexColor('#388E3C')
        
        story.append(Paragraph(f"<b>Overall Risk Level: {risk_level}</b>", 
                              ParagraphStyle('RiskLevel', parent=self.styles['Normal'], 
                                           fontSize=14, textColor=risk_color)))
        
        return story
    
    def _create_methodology_section(self) -> List:
        """Create methodology section"""
        story = []
        
        story.append(Paragraph("Assessment Methodology", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        methodology_text = """
        This security assessment was conducted using Orange Sage's AI-powered penetration testing framework, 
        which combines automated vulnerability scanning with intelligent analysis and manual verification techniques.
        
        <b>Phase 1: Reconnaissance</b><br/>
        ‚Ä¢ Information gathering and target enumeration<br/>
        ‚Ä¢ Technology fingerprinting and service identification<br/>
        ‚Ä¢ Network and application mapping<br/>
        
        <b>Phase 2: Vulnerability Scanning</b><br/>
        ‚Ä¢ Automated vulnerability detection using multiple techniques<br/>
        ‚Ä¢ Custom payload injection and testing<br/>
        ‚Ä¢ Configuration analysis and security header assessment<br/>
        
        <b>Phase 3: Exploitation Testing</b><br/>
        ‚Ä¢ Manual verification of identified vulnerabilities<br/>
        ‚Ä¢ Proof-of-concept exploitation where safe and appropriate<br/>
        ‚Ä¢ Impact assessment and risk evaluation<br/>
        
        <b>Phase 4: Analysis and Reporting</b><br/>
        ‚Ä¢ Comprehensive analysis of findings<br/>
        ‚Ä¢ Risk scoring and prioritization<br/>
        ‚Ä¢ Detailed remediation recommendations<br/>
        """
        
        story.append(Paragraph(methodology_text, self.styles['Normal']))
        
        return story
    
    def _create_findings_section(self, findings: List[Dict[str, Any]]) -> List:
        """Create detailed findings section"""
        story = []
        
        story.append(Paragraph("Detailed Findings", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        if not findings:
            story.append(Paragraph("No security findings were identified during this assessment.", 
                                  self.styles['Normal']))
            return story
        
        # Group findings by severity
        findings_by_severity = {
            'critical': [f for f in findings if f.get('severity') == 'critical'],
            'high': [f for f in findings if f.get('severity') == 'high'],
            'medium': [f for f in findings if f.get('severity') == 'medium'],
            'low': [f for f in findings if f.get('severity') == 'low']
        }
        
        for severity in ['critical', 'high', 'medium', 'low']:
            severity_findings = findings_by_severity[severity]
            if not severity_findings:
                continue
            
            # Severity header
            severity_title = f"{severity.upper()} SEVERITY FINDINGS ({len(severity_findings)})"
            story.append(Paragraph(severity_title, self.styles['SectionHeader']))
            story.append(Spacer(1, 12))
            
            # Individual findings
            for i, finding in enumerate(severity_findings, 1):
                story.extend(self._create_finding_detail(finding, i))
                story.append(Spacer(1, 20))
        
        return story
    
    def _create_finding_detail(self, finding: Dict[str, Any], finding_number: int) -> List:
        """Create detailed finding information"""
        story = []
        
        # Finding title
        title = f"Finding {finding_number}: {finding.get('title', 'Security Finding')}"
        story.append(Paragraph(title, self.styles['FindingTitle']))
        story.append(Spacer(1, 8))
        
        # Finding details table
        details_data = [
            ['Severity:', finding.get('severity', 'Unknown').upper()],
            ['Type:', finding.get('type', 'Unknown')],
            ['Endpoint:', finding.get('endpoint', 'N/A')],
            ['Parameter:', finding.get('parameter', 'N/A')],
            ['Payload:', finding.get('payload', 'N/A')]
        ]
        
        details_table = Table(details_data, colWidths=[1.5*inch, 4.5*inch])
        details_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F5F5F5')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(details_table)
        story.append(Spacer(1, 12))
        
        # Description
        story.append(Paragraph("<b>Description:</b>", self.styles['Normal']))
        story.append(Paragraph(finding.get('description', 'No description available.'), 
                              self.styles['Normal']))
        story.append(Spacer(1, 8))
        
        # Remediation
        if finding.get('remediation'):
            story.append(Paragraph("<b>Remediation:</b>", self.styles['Normal']))
            story.append(Paragraph(finding['remediation'], self.styles['Normal']))
            story.append(Spacer(1, 8))
        
        # References
        if finding.get('references'):
            story.append(Paragraph("<b>References:</b>", self.styles['Normal']))
            refs = finding['references']
            ref_text = ""
            for ref_type, ref_url in refs.items():
                ref_text += f"‚Ä¢ {ref_type.upper()}: {ref_url}<br/>"
            story.append(Paragraph(ref_text, self.styles['Normal']))
        
        return story
    
    def _create_risk_assessment_section(self, findings: List[Dict[str, Any]]) -> List:
        """Create risk assessment section"""
        story = []
        
        story.append(Paragraph("Risk Assessment", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        # Calculate risk metrics
        total_findings = len(findings)
        critical_count = len([f for f in findings if f.get('severity') == 'critical'])
        high_count = len([f for f in findings if f.get('severity') == 'high'])
        medium_count = len([f for f in findings if f.get('severity') == 'medium'])
        low_count = len([f for f in findings if f.get('severity') == 'low'])
        
        # Risk score
        risk_score = (critical_count * 10 + high_count * 7 + medium_count * 4 + low_count * 1)
        risk_score = min(risk_score, 100)
        
        # Risk assessment text
        risk_text = f"""
        <b>Risk Metrics:</b><br/>
        ‚Ä¢ Total Security Findings: {total_findings}<br/>
        ‚Ä¢ Critical Severity: {critical_count} findings<br/>
        ‚Ä¢ High Severity: {high_count} findings<br/>
        ‚Ä¢ Medium Severity: {medium_count} findings<br/>
        ‚Ä¢ Low Severity: {low_count} findings<br/>
        ‚Ä¢ Calculated Risk Score: {risk_score}/100<br/><br/>
        
        <b>Risk Level Interpretation:</b><br/>
        """
        
        if risk_score >= 80:
            risk_text += "‚Ä¢ <b>CRITICAL RISK</b> - Immediate action required to address security vulnerabilities<br/>"
        elif risk_score >= 60:
            risk_text += "‚Ä¢ <b>HIGH RISK</b> - Prompt remediation recommended<br/>"
        elif risk_score >= 40:
            risk_text += "‚Ä¢ <b>MEDIUM RISK</b> - Address findings within reasonable timeframe<br/>"
        else:
            risk_text += "‚Ä¢ <b>LOW RISK</b> - Monitor and address as part of regular maintenance<br/>"
        
        story.append(Paragraph(risk_text, self.styles['Normal']))
        
        return story
    
    def _create_recommendations_section(self, findings: List[Dict[str, Any]]) -> List:
        """Create recommendations section"""
        story = []
        
        story.append(Paragraph("Security Recommendations", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        # Generate recommendations based on findings
        recommendations = self._generate_recommendations(findings)
        
        for i, rec in enumerate(recommendations, 1):
            story.append(Paragraph(f"{i}. {rec}", self.styles['Normal']))
            story.append(Spacer(1, 8))
        
        return story
    
    def _create_technical_details_section(
        self,
        scan_data: Dict[str, Any],
        findings: List[Dict[str, Any]]
    ) -> List:
        """Create technical details section"""
        story = []
        
        story.append(Paragraph("Technical Details", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        # Scan configuration
        story.append(Paragraph("<b>Scan Configuration:</b>", self.styles['Normal']))
        story.append(Spacer(1, 8))
        
        config_data = [
            ['Scan ID:', scan_data.get('id', 'N/A')],
            ['Scan Type:', scan_data.get('scan_type', 'Comprehensive Security Assessment')],
            ['Start Time:', scan_data.get('started_at', 'N/A')],
            ['End Time:', scan_data.get('finished_at', 'N/A')],
            ['Duration:', scan_data.get('duration', 'N/A')],
            ['Agent Count:', scan_data.get('agent_count', 'N/A')]
        ]
        
        config_table = Table(config_data, colWidths=[2*inch, 4*inch])
        config_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F5F5F5')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(config_table)
        story.append(Spacer(1, 20))
        
        # Tools and techniques used
        story.append(Paragraph("<b>Tools and Techniques Used:</b>", self.styles['Normal']))
        story.append(Spacer(1, 8))
        
        tools_text = """
        ‚Ä¢ Orange Sage AI Pentesting Agent<br/>
        ‚Ä¢ Custom Python Security Scripts<br/>
        ‚Ä¢ HTTP Request/Response Analysis<br/>
        ‚Ä¢ SQL Injection Payload Testing<br/>
        ‚Ä¢ Cross-Site Scripting (XSS) Testing<br/>
        ‚Ä¢ Command Injection Testing<br/>
        ‚Ä¢ Path Traversal Testing<br/>
        ‚Ä¢ SSL/TLS Configuration Analysis<br/>
        ‚Ä¢ Security Header Assessment<br/>
        ‚Ä¢ Session Management Testing<br/>
        """
        
        story.append(Paragraph(tools_text, self.styles['Normal']))
        
        return story
    
    def _create_appendix_section(
        self,
        scan_data: Dict[str, Any],
        findings: List[Dict[str, Any]]
    ) -> List:
        """Create appendix section"""
        story = []
        
        story.append(Paragraph("Appendix", self.styles['SectionHeader']))
        story.append(Spacer(1, 12))
        
        # Raw findings data
        story.append(Paragraph("<b>Raw Findings Data:</b>", self.styles['Normal']))
        story.append(Spacer(1, 8))
        
        # Create a table with all findings
        if findings:
            findings_data = [['Title', 'Severity', 'Type', 'Endpoint']]
            for finding in findings:
                findings_data.append([
                    finding.get('title', 'N/A')[:50] + '...' if len(finding.get('title', '')) > 50 else finding.get('title', 'N/A'),
                    finding.get('severity', 'N/A'),
                    finding.get('type', 'N/A'),
                    finding.get('endpoint', 'N/A')[:30] + '...' if len(finding.get('endpoint', '')) > 30 else finding.get('endpoint', 'N/A')
                ])
            
            findings_table = Table(findings_data, colWidths=[2*inch, 1*inch, 1.5*inch, 2*inch])
            findings_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E86AB')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            story.append(findings_table)
        
        return story
    
    def _generate_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = []
        
        # Analyze findings and generate specific recommendations
        critical_findings = [f for f in findings if f.get('severity') == 'critical']
        if critical_findings:
            recommendations.append("Immediately address all critical severity findings as they pose the highest risk to the organization.")
        
        sql_injection = [f for f in findings if f.get('type') == 'sql_injection']
        if sql_injection:
            recommendations.append("Implement parameterized queries and prepared statements to prevent SQL injection attacks.")
        
        xss_findings = [f for f in findings if f.get('type') == 'xss']
        if xss_findings:
            recommendations.append("Implement proper input validation and output encoding to prevent Cross-Site Scripting (XSS) attacks.")
        
        command_injection = [f for f in findings if f.get('type') == 'command_injection']
        if command_injection:
            recommendations.append("Avoid executing user input as system commands and implement proper input sanitization.")
        
        path_traversal = [f for f in findings if f.get('type') == 'path_traversal']
        if path_traversal:
            recommendations.append("Implement proper file path validation and access controls to prevent directory traversal attacks.")
        
        missing_headers = [f for f in findings if 'security headers' in f.get('title', '').lower()]
        if missing_headers:
            recommendations.append("Implement comprehensive security headers including Content-Security-Policy, X-Frame-Options, and others.")
        
        ssl_issues = [f for f in findings if f.get('type') == 'ssl_tls']
        if ssl_issues:
            recommendations.append("Review and strengthen SSL/TLS configuration, including cipher suites and certificate management.")
        
        session_issues = [f for f in findings if f.get('type') == 'session_management']
        if session_issues:
            recommendations.append("Implement secure session management practices including secure cookies and session timeout.")
        
        # General recommendations
        recommendations.extend([
            "Conduct regular security assessments and penetration testing.",
            "Implement a Web Application Firewall (WAF) to provide additional protection.",
            "Establish a security awareness training program for development teams.",
            "Implement a secure development lifecycle (SDL) process.",
            "Regularly update and patch all software components.",
            "Implement comprehensive logging and monitoring for security events."
        ])
        
        return recommendations
    
    async def generate_html_report(
        self,
        scan_data: Dict[str, Any],
        findings: List[Dict[str, Any]],
        target_info: Dict[str, Any],
        branding: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate HTML report"""
        try:
            # HTML template
            html_template = """
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Orange Sage Security Assessment Report</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
                    .header { text-align: center; color: #2E86AB; border-bottom: 2px solid #2E86AB; padding-bottom: 20px; }
                    .section { margin: 30px 0; }
                    .finding { border: 1px solid #ddd; margin: 15px 0; padding: 15px; border-radius: 5px; }
                    .critical { border-left: 5px solid #D32F2F; background-color: #FFEBEE; }
                    .high { border-left: 5px solid #F57C00; background-color: #FFF3E0; }
                    .medium { border-left: 5px solid #FBC02D; background-color: #FFFDE7; }
                    .low { border-left: 5px solid #388E3C; background-color: #E8F5E8; }
                    .stats { display: flex; justify-content: space-around; margin: 20px 0; }
                    .stat-box { text-align: center; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
                    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Orange Sage Security Assessment Report</h1>
                    <h2>{{ target_info.url or target_info.hostname }}</h2>
                    <p>Generated on: {{ scan_data.created_at or 'N/A' }}</p>
                </div>
                
                <div class="section">
                    <h2>Executive Summary</h2>
                    <div class="stats">
                        <div class="stat-box">
                            <h3>{{ findings|length }}</h3>
                            <p>Total Findings</p>
                        </div>
                        <div class="stat-box">
                            <h3>{{ findings|selectattr('severity', 'equalto', 'critical')|list|length }}</h3>
                            <p>Critical</p>
                        </div>
                        <div class="stat-box">
                            <h3>{{ findings|selectattr('severity', 'equalto', 'high')|list|length }}</h3>
                            <p>High</p>
                        </div>
                        <div class="stat-box">
                            <h3>{{ findings|selectattr('severity', 'equalto', 'medium')|list|length }}</h3>
                            <p>Medium</p>
                        </div>
                        <div class="stat-box">
                            <h3>{{ findings|selectattr('severity', 'equalto', 'low')|list|length }}</h3>
                            <p>Low</p>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Detailed Findings</h2>
                    {% for finding in findings %}
                    <div class="finding {{ finding.severity }}">
                        <h3>{{ finding.title }}</h3>
                        <p><strong>Severity:</strong> {{ finding.severity|upper }}</p>
                        <p><strong>Type:</strong> {{ finding.type }}</p>
                        <p><strong>Endpoint:</strong> {{ finding.endpoint }}</p>
                        <p><strong>Description:</strong> {{ finding.description }}</p>
                        {% if finding.remediation %}
                        <p><strong>Remediation:</strong> {{ finding.remediation }}</p>
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>
                
                <div class="section">
                    <h2>Recommendations</h2>
                    <ul>
                        {% for rec in recommendations %}
                        <li>{{ rec }}</li>
                        {% endfor %}
                    </ul>
                </div>
            </body>
            </html>
            """
            
            # Generate recommendations
            recommendations = self._generate_recommendations(findings)
            
            # Render template
            template = Template(html_template)
            html_content = template.render(
                scan_data=scan_data,
                findings=findings,
                target_info=target_info,
                recommendations=recommendations
            )
            
            return html_content
            
        except Exception as e:
            logger.error(f"Error generating HTML report: {e}")
            raise


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\agent_manager.py
"""
Agent Manager Service for Orange Sage
Handles AI agent orchestration and execution
"""

import asyncio
import logging
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any
from sqlalchemy.orm import Session

from app.core.config import settings
from app.models.scan import Scan, ScanStatus
from app.models.agent import Agent, AgentStatus
from app.models.finding import Finding, SeverityLevel
from app.services.llm_service import LLMService
from app.services.sandbox_service import SandboxService
from app.utils.agent_factory import AgentFactory

logger = logging.getLogger(__name__)


class AgentManager:
    """Manages AI agents for security assessments"""
    
    def __init__(self):
        self.llm_service = LLMService()
        self.sandbox_service = SandboxService()
        self.agent_factory = AgentFactory()
        self.active_agents: Dict[str, Any] = {}
        self.active_scans: Dict[str, Any] = {}
    
    async def start_scan(self, db: Session, scan_id: int, scan_config: Dict[str, Any]) -> Dict[str, Any]:
        """Start a new security scan with AI agents"""
        try:
            # Get scan from database
            scan = db.query(Scan).filter(Scan.id == scan_id).first()
            if not scan:
                raise ValueError(f"Scan {scan_id} not found")
            
            # Update scan status
            scan.status = ScanStatus.RUNNING
            scan.started_at = datetime.utcnow()
            db.commit()
            
            # Store scan info
            self.active_scans[str(scan_id)] = {
                "scan_id": scan_id,
                "scan": scan,
                "agents": {},
                "findings": [],
                "status": "running"
            }
            
            # Create root agent
            root_agent = await self._create_root_agent(scan, scan_config)
            
            # Start agent execution
            asyncio.create_task(self._execute_agent(root_agent, db))
            
            logger.info(f"Started scan {scan_id} with root agent {root_agent.agent_id}")
            
            return {
                "scan_id": scan_id,
                "status": "started",
                "root_agent_id": root_agent.agent_id,
                "message": "Scan started successfully"
            }
            
        except Exception as e:
            logger.error(f"Error starting scan {scan_id}: {e}")
            # Update scan status to failed
            if scan:
                scan.status = ScanStatus.FAILED
                scan.error_message = str(e)
                db.commit()
            raise
    
    async def _create_root_agent(self, scan: Scan, scan_config: Dict[str, Any]) -> Agent:
        """Create root agent for scan"""
        agent_id = str(uuid.uuid4())
        
        # Create agent record
        agent = Agent(
            agent_id=agent_id,
            name="Orange Sage Root Agent",
            task=f"Perform comprehensive security assessment of {scan.target.value}",
            status=AgentStatus.PENDING,
            scan_id=scan.id,
            agent_type="OrangeSageAgent",
            prompt_modules=["root_agent"],
            llm_config={
                "model_name": settings.DEFAULT_LLM_MODEL,
                "temperature": 0.7,
                "max_tokens": 4000
            }
        )
        
        return agent
    
    async def _execute_agent(self, agent: Agent, db: Session):
        """Execute an agent"""
        try:
            # Update agent status
            agent.status = AgentStatus.RUNNING
            agent.started_at = datetime.utcnow()
            db.commit()
            
            # Create sandbox for agent
            sandbox_info = await self.sandbox_service.create_sandbox(agent.agent_id)
            agent.sandbox_id = sandbox_info["workspace_id"]
            db.commit()
            
            # Initialize agent instance
            agent_instance = self.agent_factory.create_agent(
                agent_type=agent.agent_type,
                config={
                    "agent_id": agent.agent_id,
                    "task": agent.task,
                    "sandbox_info": sandbox_info,
                    "llm_config": agent.llm_config
                }
            )
            
            # Store active agent
            self.active_agents[agent.agent_id] = {
                "agent": agent,
                "instance": agent_instance,
                "db": db
            }
            
            # Execute agent
            result = await agent_instance.execute()
            
            # Process results
            await self._process_agent_results(agent, result, db)
            
            # Update agent status
            agent.status = AgentStatus.COMPLETED
            agent.finished_at = datetime.utcnow()
            agent.final_result = result
            db.commit()
            
            logger.info(f"Agent {agent.agent_id} completed successfully")
            
        except Exception as e:
            logger.error(f"Error executing agent {agent.agent_id}: {e}")
            agent.status = AgentStatus.FAILED
            agent.error_message = str(e)
            agent.finished_at = datetime.utcnow()
            db.commit()
            
        finally:
            # Cleanup
            if agent.agent_id in self.active_agents:
                del self.active_agents[agent.agent_id]
            
            # Cleanup sandbox
            if agent.sandbox_id:
                await self.sandbox_service.destroy_sandbox(agent.sandbox_id)
    
    async def _process_agent_results(self, agent: Agent, result: Dict[str, Any], db: Session):
        """Process agent execution results"""
        try:
            # Extract findings from result
            findings = result.get("findings", [])
            
            for finding_data in findings:
                finding = Finding(
                    title=finding_data.get("title", "Security Finding"),
                    description=finding_data.get("description", ""),
                    severity=SeverityLevel(finding_data.get("severity", "medium")),
                    scan_id=agent.scan_id,
                    vulnerability_type=finding_data.get("type", ""),
                    endpoint=finding_data.get("endpoint", ""),
                    parameter=finding_data.get("parameter", ""),
                    method=finding_data.get("method", ""),
                    request_sample=finding_data.get("request_sample", ""),
                    response_sample=finding_data.get("response_sample", ""),
                    poc_artifact_key=finding_data.get("poc_artifact_key", ""),
                    remediation_text=finding_data.get("remediation", ""),
                    references=finding_data.get("references", {}),
                    created_by_agent=agent.agent_id
                )
                
                db.add(finding)
            
            db.commit()
            
            # Update scan summary
            scan = db.query(Scan).filter(Scan.id == agent.scan_id).first()
            if scan:
                scan.summary = {
                    "total_findings": len(findings),
                    "critical_count": len([f for f in findings if f.get("severity") == "critical"]),
                    "high_count": len([f for f in findings if f.get("severity") == "high"]),
                    "medium_count": len([f for f in findings if f.get("severity") == "medium"]),
                    "low_count": len([f for f in findings if f.get("severity") == "low"]),
                    "agents_completed": 1
                }
                db.commit()
            
        except Exception as e:
            logger.error(f"Error processing agent results: {e}")
    
    async def get_scan_status(self, scan_id: int, db: Session) -> Dict[str, Any]:
        """Get scan status and progress"""
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            return {"error": "Scan not found"}
        
        # Get agents for this scan
        agents = db.query(Agent).filter(Agent.scan_id == scan_id).all()
        
        # Get findings count
        findings_count = db.query(Finding).filter(Finding.scan_id == scan_id).count()
        
        return {
            "scan_id": scan_id,
            "status": scan.status.value,
            "name": scan.name,
            "target": scan.target.value if scan.target else None,
            "agents_count": len(agents),
            "findings_count": findings_count,
            "started_at": scan.started_at.isoformat() if scan.started_at else None,
            "finished_at": scan.finished_at.isoformat() if scan.finished_at else None,
            "summary": scan.summary,
            "error": scan.error_message
        }
    
    async def get_scan_agents(self, scan_id: int, db: Session) -> List[Dict[str, Any]]:
        """Get agents for a scan"""
        agents = db.query(Agent).filter(Agent.scan_id == scan_id).all()
        
        return [
            {
                "id": agent.agent_id,
                "name": agent.name,
                "status": agent.status.value,
                "task": agent.task,
                "iteration": agent.iteration,
                "max_iterations": agent.max_iterations,
                "started_at": agent.started_at.isoformat() if agent.started_at else None,
                "finished_at": agent.finished_at.isoformat() if agent.finished_at else None,
                "error": agent.error_message
            }
            for agent in agents
        ]
    
    async def cancel_scan(self, scan_id: int, db: Session) -> Dict[str, Any]:
        """Cancel a running scan"""
        try:
            # Update scan status
            scan = db.query(Scan).filter(Scan.id == scan_id).first()
            if not scan:
                return {"error": "Scan not found"}
            
            scan.status = ScanStatus.CANCELLED
            scan.finished_at = datetime.utcnow()
            db.commit()
            
            # Cancel active agents
            agents = db.query(Agent).filter(
                Agent.scan_id == scan_id,
                Agent.status == AgentStatus.RUNNING
            ).all()
            
            for agent in agents:
                agent.status = AgentStatus.CANCELLED
                agent.finished_at = datetime.utcnow()
                
                # Cancel active agent instance
                if agent.agent_id in self.active_agents:
                    try:
                        await self.active_agents[agent.agent_id]["instance"].cancel()
                    except Exception as e:
                        logger.error(f"Error cancelling agent {agent.agent_id}: {e}")
            
            db.commit()
            
            return {
                "scan_id": scan_id,
                "status": "cancelled",
                "message": "Scan cancelled successfully"
            }
            
        except Exception as e:
            logger.error(f"Error cancelling scan {scan_id}: {e}")
            return {"error": str(e)}
    
    async def cleanup(self):
        """Cleanup resources"""
        try:
            # Cancel all active agents
            for agent_id, agent_info in self.active_agents.items():
                try:
                    await agent_info["instance"].cancel()
                except Exception as e:
                    logger.error(f"Error cancelling agent {agent_id}: {e}")
            
            # Cleanup sandboxes
            await self.sandbox_service.cleanup_all()
            
            logger.info("Agent manager cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\llm_service.py
"""
LLM Service for Orange Sage
Handles LLM API calls and model management
"""

import logging
import openai
import google.generativeai as genai
from typing import Dict, List, Any, Optional
from app.core.config import settings

logger = logging.getLogger(__name__)


class LLMService:
    """Service for managing LLM interactions"""
    
    def __init__(self):
        self.openai_client = None
        self.gemini_client = None
        self._initialize_clients()
    
    def _initialize_clients(self):
        """Initialize LLM clients"""
        try:
            # Initialize OpenAI
            if settings.OPENAI_API_KEY:
                openai.api_key = settings.OPENAI_API_KEY
                self.openai_client = openai
                logger.info("OpenAI client initialized")
            
            # Initialize Gemini
            if settings.GEMINI_API_KEY:
                genai.configure(api_key=settings.GEMINI_API_KEY)
                self.gemini_client = genai
                logger.info("Gemini client initialized")
                
        except Exception as e:
            logger.error(f"Error initializing LLM clients: {e}")
    
    async def generate_response(
        self,
        messages: List[Dict[str, str]],
        model: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: int = 4000
    ) -> Dict[str, Any]:
        """Generate response using LLM"""
        try:
            # Use default model if not specified
            if not model:
                model = settings.DEFAULT_LLM_MODEL
            
            # Try OpenAI first
            if self.openai_client and "gpt" in model.lower():
                return await self._generate_openai_response(
                    messages, model, temperature, max_tokens
                )
            
            # Try Gemini as fallback
            elif self.gemini_client and "gemini" in model.lower():
                return await self._generate_gemini_response(
                    messages, model, temperature, max_tokens
                )
            
            # Fallback to available model
            if self.openai_client:
                return await self._generate_openai_response(
                    messages, settings.DEFAULT_LLM_MODEL, temperature, max_tokens
                )
            elif self.gemini_client:
                return await self._generate_gemini_response(
                    messages, settings.FALLBACK_LLM_MODEL, temperature, max_tokens
                )
            
            raise Exception("No LLM client available")
            
        except Exception as e:
            logger.error(f"Error generating LLM response: {e}")
            raise
    
    async def _generate_openai_response(
        self,
        messages: List[Dict[str, str]],
        model: str,
        temperature: float,
        max_tokens: int
    ) -> Dict[str, Any]:
        """Generate response using OpenAI"""
        try:
            response = await self.openai_client.ChatCompletion.acreate(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            
            return {
                "content": response.choices[0].message.content,
                "model": model,
                "usage": response.usage.dict() if response.usage else None,
                "provider": "openai"
            }
            
        except Exception as e:
            logger.error(f"OpenAI API error: {e}")
            raise
    
    async def _generate_gemini_response(
        self,
        messages: List[Dict[str, str]],
        model: str,
        temperature: float,
        max_tokens: int
    ) -> Dict[str, Any]:
        """Generate response using Gemini"""
        try:
            # Convert messages to Gemini format
            # Gemini expects a single prompt string or a list of content parts
            prompt_parts = []
            system_prompt = ""
            
            for msg in messages:
                if msg["role"] == "system":
                    system_prompt = msg["content"]
                elif msg["role"] == "user":
                    prompt_parts.append(msg["content"])
                elif msg["role"] == "assistant":
                    # For conversation history, we'll include assistant responses
                    prompt_parts.append(f"Assistant: {msg['content']}")
            
            # Combine system prompt with user messages
            full_prompt = system_prompt
            if prompt_parts:
                full_prompt += "\n\n" + "\n\n".join(prompt_parts)
            
            # Generate response
            model_instance = self.gemini_client.GenerativeModel(model)
            response = await model_instance.generate_content_async(
                full_prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=temperature,
                    max_output_tokens=max_tokens
                )
            )
            
            # Check for blocked content or other issues
            if not response.candidates:
                raise Exception("No candidates returned from Gemini API")
            
            candidate = response.candidates[0]
            if candidate.finish_reason == 2:  # SAFETY
                raise Exception("Content was blocked by Gemini safety filters")
            elif candidate.finish_reason == 3:  # RECITATION
                raise Exception("Content was blocked due to recitation concerns")
            elif candidate.finish_reason == 4:  # OTHER
                raise Exception("Content generation failed for other reasons")
            
            # Check if response has content
            if not candidate.content or not candidate.content.parts:
                raise Exception("No content parts in Gemini response")
            
            # Extract text content
            content = ""
            for part in candidate.content.parts:
                if hasattr(part, 'text') and part.text:
                    content += part.text
            
            if not content:
                raise Exception("No text content found in Gemini response")
            
            return {
                "content": content,
                "model": model,
                "usage": None,  # Gemini doesn't provide usage info in the same format
                "provider": "gemini"
            }
            
        except Exception as e:
            logger.error(f"Gemini API error: {e}")
            raise
    
    def get_available_models(self) -> List[str]:
        """Get list of available models"""
        models = []
        
        if self.openai_client:
            models.extend([
                "gpt-4o",
                "gpt-4o-mini",
                "gpt-4-turbo",
                "gpt-3.5-turbo"
            ])
        
        if self.gemini_client:
            try:
                # Try to get available models from Gemini API
                available_models = self.gemini_client.list_models()
                for model in available_models:
                    if 'generateContent' in model.supported_generation_methods:
                        models.append(model.name.replace('models/', ''))
            except Exception as e:
                logger.warning(f"Could not fetch Gemini models dynamically: {e}")
                # Fallback to known models
                models.extend([
                    "gemini-1.5-pro",
                    "gemini-1.5-flash-002",
                    "gemini-2.0-flash-lite",
                    "gemini-2.0-flash-exp"
                ])
        
        return models
    
    def is_model_available(self, model: str) -> bool:
        """Check if a model is available"""
        return model in self.get_available_models()
    
    async def test_connection(self) -> Dict[str, Any]:
        """Test LLM connections"""
        results = {
            "openai": {"available": False, "error": None},
            "gemini": {"available": False, "error": None}
        }
        
        # Test OpenAI
        if self.openai_client:
            try:
                await self._generate_openai_response(
                    [{"role": "user", "content": "Hello"}],
                    "gpt-3.5-turbo",
                    0.1,
                    10
                )
                results["openai"]["available"] = True
            except Exception as e:
                results["openai"]["error"] = str(e)
        
        # Test Gemini
        if self.gemini_client:
            try:
                # Try multiple model names in order of preference
                gemini_models = ["gemini-2.0-flash-lite", "gemini-1.5-flash-002", "gemini-1.5-pro"]
                success = False
                
                for model in gemini_models:
                    try:
                        await self._generate_gemini_response(
                            [{"role": "user", "content": "Hello"}],
                            model,
                            0.1,
                            10
                        )
                        results["gemini"]["available"] = True
                        success = True
                        break
                    except Exception as model_error:
                        logger.warning(f"Model {model} failed: {model_error}")
                        continue
                
                if not success:
                    results["gemini"]["error"] = "All Gemini models failed to respond"
                    
            except Exception as e:
                results["gemini"]["error"] = str(e)
        
        return results


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\microservices_orchestrator.py
"""
Microservices Orchestrator for Orange Sage
Coordinates multiple security analysis microservices
"""

import asyncio
import json
import logging
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
import aiohttp
import requests

logger = logging.getLogger(__name__)


class MicroservicesOrchestrator:
    """Orchestrates multiple security analysis microservices"""
    
    def __init__(self):
        self.services = {
            'vulnerability_scanner': {
                'url': 'http://localhost:8001',
                'description': 'Automated vulnerability scanning service',
                'capabilities': ['sql_injection', 'xss', 'csrf', 'path_traversal']
            },
            'network_analyzer': {
                'url': 'http://localhost:8002',
                'description': 'Network security analysis service',
                'capabilities': ['port_scanning', 'service_enumeration', 'ssl_analysis']
            },
            'code_analyzer': {
                'url': 'http://localhost:8003',
                'description': 'Static code analysis service',
                'capabilities': ['static_analysis', 'dependency_check', 'secrets_detection']
            },
            'compliance_checker': {
                'url': 'http://localhost:8004',
                'description': 'Compliance and standards checking service',
                'capabilities': ['owasp_top10', 'pci_dss', 'gdpr', 'iso27001']
            },
            'threat_intelligence': {
                'url': 'http://localhost:8005',
                'description': 'Threat intelligence and IOCs analysis',
                'capabilities': ['ioc_analysis', 'threat_hunting', 'malware_analysis']
            },
            'report_generator': {
                'url': 'http://localhost:8006',
                'description': 'Advanced report generation service',
                'capabilities': ['pdf_generation', 'html_reports', 'executive_summaries']
            }
        }
        self.active_tasks = {}
    
    async def start_comprehensive_analysis(
        self,
        target: str,
        analysis_config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Start comprehensive security analysis using multiple microservices"""
        try:
            analysis_id = str(uuid.uuid4())
            logger.info(f"Starting comprehensive analysis {analysis_id} for target: {target}")
            
            # Initialize analysis session
            analysis_session = {
                'id': analysis_id,
                'target': target,
                'config': analysis_config,
                'started_at': datetime.now(),
                'services': {},
                'findings': [],
                'status': 'running'
            }
            
            # Start parallel analysis tasks
            tasks = []
            
            # Vulnerability scanning
            if analysis_config.get('enable_vulnerability_scanning', True):
                task = asyncio.create_task(
                    self._run_vulnerability_scanning(analysis_id, target, analysis_config)
                )
                tasks.append(task)
            
            # Network analysis
            if analysis_config.get('enable_network_analysis', True):
                task = asyncio.create_task(
                    self._run_network_analysis(analysis_id, target, analysis_config)
                )
                tasks.append(task)
            
            # Code analysis (if applicable)
            if analysis_config.get('enable_code_analysis', False):
                task = asyncio.create_task(
                    self._run_code_analysis(analysis_id, target, analysis_config)
                )
                tasks.append(task)
            
            # Compliance checking
            if analysis_config.get('enable_compliance_checking', True):
                task = asyncio.create_task(
                    self._run_compliance_checking(analysis_id, target, analysis_config)
                )
                tasks.append(task)
            
            # Threat intelligence
            if analysis_config.get('enable_threat_intelligence', True):
                task = asyncio.create_task(
                    self._run_threat_intelligence(analysis_id, target, analysis_config)
                )
                tasks.append(task)
            
            # Store active analysis
            self.active_tasks[analysis_id] = {
                'session': analysis_session,
                'tasks': tasks
            }
            
            # Wait for all tasks to complete
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Process results
            analysis_session['status'] = 'completed'
            analysis_session['completed_at'] = datetime.now()
            
            # Aggregate findings from all services
            all_findings = []
            for result in results:
                if isinstance(result, dict) and 'findings' in result:
                    all_findings.extend(result['findings'])
            
            analysis_session['findings'] = all_findings
            analysis_session['summary'] = self._generate_analysis_summary(all_findings)
            
            # Generate comprehensive report
            if analysis_config.get('generate_report', True):
                report_task = asyncio.create_task(
                    self._generate_comprehensive_report(analysis_id, analysis_session)
                )
                await report_task
            
            logger.info(f"Analysis {analysis_id} completed with {len(all_findings)} findings")
            
            return {
                'analysis_id': analysis_id,
                'status': 'completed',
                'findings': all_findings,
                'summary': analysis_session['summary'],
                'duration': (analysis_session['completed_at'] - analysis_session['started_at']).total_seconds()
            }
            
        except Exception as e:
            logger.error(f"Error in comprehensive analysis: {e}")
            return {'error': str(e), 'status': 'failed'}
    
    async def _run_vulnerability_scanning(
        self,
        analysis_id: str,
        target: str,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Run vulnerability scanning microservice"""
        try:
            service_url = self.services['vulnerability_scanner']['url']
            
            # Prepare scan request
            scan_request = {
                'analysis_id': analysis_id,
                'target': target,
                'scan_types': config.get('scan_types', ['web', 'api']),
                'depth': config.get('scan_depth', 'comprehensive'),
                'options': {
                    'enable_sql_injection': True,
                    'enable_xss': True,
                    'enable_csrf': True,
                    'enable_path_traversal': True,
                    'enable_command_injection': True,
                    'enable_authentication_bypass': True
                }
            }
            
            # Call vulnerability scanning service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/scan",
                    json=scan_request,
                    timeout=aiohttp.ClientTimeout(total=300)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Vulnerability scanning completed for {target}")
                        return result
                    else:
                        logger.error(f"Vulnerability scanning failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in vulnerability scanning: {e}")
            return {'error': str(e)}
    
    async def _run_network_analysis(
        self,
        analysis_id: str,
        target: str,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Run network analysis microservice"""
        try:
            service_url = self.services['network_analyzer']['url']
            
            # Prepare network analysis request
            network_request = {
                'analysis_id': analysis_id,
                'target': target,
                'analysis_types': config.get('network_analysis_types', ['port_scan', 'ssl_analysis', 'service_enumeration']),
                'options': {
                    'port_range': config.get('port_range', '1-65535'),
                    'scan_techniques': ['tcp_syn', 'tcp_connect', 'udp'],
                    'ssl_analysis': True,
                    'banner_grabbing': True
                }
            }
            
            # Call network analysis service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/analyze",
                    json=network_request,
                    timeout=aiohttp.ClientTimeout(total=600)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Network analysis completed for {target}")
                        return result
                    else:
                        logger.error(f"Network analysis failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in network analysis: {e}")
            return {'error': str(e)}
    
    async def _run_code_analysis(
        self,
        analysis_id: str,
        target: str,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Run code analysis microservice"""
        try:
            service_url = self.services['code_analyzer']['url']
            
            # Prepare code analysis request
            code_request = {
                'analysis_id': analysis_id,
                'target': target,
                'analysis_types': config.get('code_analysis_types', ['static_analysis', 'dependency_check']),
                'options': {
                    'languages': config.get('languages', ['python', 'javascript', 'java', 'php']),
                    'check_secrets': True,
                    'check_dependencies': True,
                    'check_hardcoded_credentials': True
                }
            }
            
            # Call code analysis service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/analyze",
                    json=code_request,
                    timeout=aiohttp.ClientTimeout(total=900)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Code analysis completed for {target}")
                        return result
                    else:
                        logger.error(f"Code analysis failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in code analysis: {e}")
            return {'error': str(e)}
    
    async def _run_compliance_checking(
        self,
        analysis_id: str,
        target: str,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Run compliance checking microservice"""
        try:
            service_url = self.services['compliance_checker']['url']
            
            # Prepare compliance check request
            compliance_request = {
                'analysis_id': analysis_id,
                'target': target,
                'standards': config.get('compliance_standards', ['owasp_top10', 'pci_dss']),
                'options': {
                    'check_authentication': True,
                    'check_authorization': True,
                    'check_data_protection': True,
                    'check_encryption': True,
                    'check_logging': True
                }
            }
            
            # Call compliance checking service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/check",
                    json=compliance_request,
                    timeout=aiohttp.ClientTimeout(total=300)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Compliance checking completed for {target}")
                        return result
                    else:
                        logger.error(f"Compliance checking failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in compliance checking: {e}")
            return {'error': str(e)}
    
    async def _run_threat_intelligence(
        self,
        analysis_id: str,
        target: str,
        config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Run threat intelligence microservice"""
        try:
            service_url = self.services['threat_intelligence']['url']
            
            # Prepare threat intelligence request
            ti_request = {
                'analysis_id': analysis_id,
                'target': target,
                'analysis_types': config.get('ti_analysis_types', ['ioc_analysis', 'threat_hunting']),
                'options': {
                    'check_known_malicious': True,
                    'check_suspicious_patterns': True,
                    'check_network_indicators': True,
                    'check_file_indicators': True
                }
            }
            
            # Call threat intelligence service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/analyze",
                    json=ti_request,
                    timeout=aiohttp.ClientTimeout(total=600)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Threat intelligence analysis completed for {target}")
                        return result
                    else:
                        logger.error(f"Threat intelligence analysis failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in threat intelligence analysis: {e}")
            return {'error': str(e)}
    
    async def _generate_comprehensive_report(
        self,
        analysis_id: str,
        analysis_session: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate comprehensive report using report generation microservice"""
        try:
            service_url = self.services['report_generator']['url']
            
            # Prepare report generation request
            report_request = {
                'analysis_id': analysis_id,
                'target': analysis_session['target'],
                'findings': analysis_session['findings'],
                'summary': analysis_session['summary'],
                'formats': ['pdf', 'html'],
                'options': {
                    'include_executive_summary': True,
                    'include_technical_details': True,
                    'include_recommendations': True,
                    'include_appendix': True,
                    'branding': {
                        'company_name': 'Orange Sage',
                        'logo_url': None,
                        'color_scheme': 'blue'
                    }
                }
            }
            
            # Call report generation service
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service_url}/generate",
                    json=report_request,
                    timeout=aiohttp.ClientTimeout(total=300)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Comprehensive report generated for analysis {analysis_id}")
                        return result
                    else:
                        logger.error(f"Report generation failed: {response.status}")
                        return {'error': f'Service returned status {response.status}'}
        
        except Exception as e:
            logger.error(f"Error in report generation: {e}")
            return {'error': str(e)}
    
    def _generate_analysis_summary(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate analysis summary from findings"""
        total_findings = len(findings)
        critical_count = len([f for f in findings if f.get('severity') == 'critical'])
        high_count = len([f for f in findings if f.get('severity') == 'high'])
        medium_count = len([f for f in findings if f.get('severity') == 'medium'])
        low_count = len([f for f in findings if f.get('severity') == 'low'])
        
        # Calculate risk score
        risk_score = (critical_count * 10 + high_count * 7 + medium_count * 4 + low_count * 1)
        risk_score = min(risk_score, 100)
        
        # Determine risk level
        if risk_score >= 80:
            risk_level = "CRITICAL"
        elif risk_score >= 60:
            risk_level = "HIGH"
        elif risk_score >= 40:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        # Group findings by type
        findings_by_type = {}
        for finding in findings:
            finding_type = finding.get('type', 'unknown')
            if finding_type not in findings_by_type:
                findings_by_type[finding_type] = 0
            findings_by_type[finding_type] += 1
        
        return {
            'total_findings': total_findings,
            'critical_count': critical_count,
            'high_count': high_count,
            'medium_count': medium_count,
            'low_count': low_count,
            'risk_score': risk_score,
            'risk_level': risk_level,
            'findings_by_type': findings_by_type,
            'top_vulnerabilities': self._get_top_vulnerabilities(findings)
        }
    
    def _get_top_vulnerabilities(self, findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Get top vulnerabilities by severity and impact"""
        # Sort findings by severity (critical first) and then by type
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        sorted_findings = sorted(
            findings,
            key=lambda x: (severity_order.get(x.get('severity', 'low'), 3), x.get('type', ''))
        )
        
        # Return top 10 most critical findings
        return sorted_findings[:10]
    
    async def get_analysis_status(self, analysis_id: str) -> Dict[str, Any]:
        """Get status of running analysis"""
        if analysis_id not in self.active_tasks:
            return {'error': 'Analysis not found'}
        
        task_info = self.active_tasks[analysis_id]
        session = task_info['session']
        
        # Check if tasks are still running
        running_tasks = [task for task in task_info['tasks'] if not task.done()]
        
        return {
            'analysis_id': analysis_id,
            'status': session['status'],
            'target': session['target'],
            'started_at': session['started_at'].isoformat(),
            'running_tasks': len(running_tasks),
            'total_tasks': len(task_info['tasks']),
            'findings_count': len(session.get('findings', [])),
            'summary': session.get('summary', {})
        }
    
    async def cancel_analysis(self, analysis_id: str) -> Dict[str, Any]:
        """Cancel running analysis"""
        if analysis_id not in self.active_tasks:
            return {'error': 'Analysis not found'}
        
        try:
            task_info = self.active_tasks[analysis_id]
            session = task_info['session']
            
            # Cancel all running tasks
            for task in task_info['tasks']:
                if not task.done():
                    task.cancel()
            
            # Update session status
            session['status'] = 'cancelled'
            session['cancelled_at'] = datetime.now()
            
            # Remove from active tasks
            del self.active_tasks[analysis_id]
            
            logger.info(f"Analysis {analysis_id} cancelled")
            
            return {
                'analysis_id': analysis_id,
                'status': 'cancelled',
                'message': 'Analysis cancelled successfully'
            }
            
        except Exception as e:
            logger.error(f"Error cancelling analysis {analysis_id}: {e}")
            return {'error': str(e)}
    
    async def get_service_status(self) -> Dict[str, Any]:
        """Get status of all microservices"""
        service_status = {}
        
        for service_name, service_info in self.services.items():
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(
                        f"{service_info['url']}/health",
                        timeout=aiohttp.ClientTimeout(total=5)
                    ) as response:
                        if response.status == 200:
                            service_status[service_name] = {
                                'status': 'healthy',
                                'url': service_info['url'],
                                'description': service_info['description']
                            }
                        else:
                            service_status[service_name] = {
                                'status': 'unhealthy',
                                'url': service_info['url'],
                                'error': f'HTTP {response.status}'
                            }
            except Exception as e:
                service_status[service_name] = {
                    'status': 'unavailable',
                    'url': service_info['url'],
                    'error': str(e)
                }
        
        return service_status
    
    async def cleanup(self):
        """Cleanup resources and cancel all active tasks"""
        try:
            for analysis_id, task_info in self.active_tasks.items():
                # Cancel all tasks
                for task in task_info['tasks']:
                    if not task.done():
                        task.cancel()
                
                # Update session status
                task_info['session']['status'] = 'cancelled'
                task_info['session']['cancelled_at'] = datetime.now()
            
            # Clear active tasks
            self.active_tasks.clear()
            
            logger.info("Microservices orchestrator cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\report_generator.py
"""
Report Generator Service for Orange Sage
Handles report generation in various formats
"""

import logging
import os
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
from sqlalchemy.orm import Session

from app.models.scan import Scan
from app.models.finding import Finding, SeverityLevel
from app.models.report import Report, ReportFormat, ReportStatus
from app.core.config import settings

logger = logging.getLogger(__name__)


class ReportGenerator:
    """Service for generating security assessment reports"""
    
    def __init__(self):
        self.reports_dir = settings.REPORTS_DIR
        self._ensure_reports_dir()
    
    def _ensure_reports_dir(self):
        """Ensure reports directory exists"""
        if not os.path.exists(self.reports_dir):
            os.makedirs(self.reports_dir, exist_ok=True)
    
    async def generate_report(
        self,
        db: Session,
        scan_id: int,
        format: ReportFormat,
        options: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Generate a report for a scan"""
        try:
            # Get scan and findings
            scan = db.query(Scan).filter(Scan.id == scan_id).first()
            if not scan:
                raise ValueError(f"Scan {scan_id} not found")
            
            findings = db.query(Finding).filter(Finding.scan_id == scan_id).all()
            
            # Create report record
            report = Report(
                name=f"Security Assessment Report - {scan.name}",
                format=format,
                status=ReportStatus.PENDING,
                scan_id=scan_id,
                include_charts=options.get("include_charts", True),
                include_pocs=options.get("include_pocs", True),
                branding=options.get("branding", "Orange Sage")
            )
            
            db.add(report)
            db.commit()
            
            # Generate report asynchronously
            import asyncio
            asyncio.create_task(self._generate_report_async(report, scan, findings, options))
            
            return {
                "report_id": report.id,
                "status": "generating",
                "message": "Report generation started"
            }
            
        except Exception as e:
            logger.error(f"Error generating report for scan {scan_id}: {e}")
            raise
    
    async def _generate_report_async(
        self,
        report: Report,
        scan: Scan,
        findings: List[Finding],
        options: Dict[str, Any]
    ):
        """Generate report asynchronously"""
        try:
            # Update report status
            report.status = ReportStatus.GENERATING
            db = report.scan.project.owner  # Get database session
            db.commit()
            
            # Generate report based on format
            if report.format == ReportFormat.PDF:
                file_path = await self._generate_pdf_report(report, scan, findings, options)
            elif report.format == ReportFormat.DOCX:
                file_path = await self._generate_docx_report(report, scan, findings, options)
            elif report.format == ReportFormat.HTML:
                file_path = await self._generate_html_report(report, scan, findings, options)
            else:
                raise ValueError(f"Unsupported report format: {report.format}")
            
            # Update report with file info
            report.status = ReportStatus.COMPLETED
            report.storage_key = file_path
            report.file_size = os.path.getsize(file_path)
            report.generated_at = datetime.utcnow()
            report.download_url = f"/api/v1/reports/{report.id}/download"
            report.expires_at = datetime.utcnow() + timedelta(hours=24)
            
            db.commit()
            
            logger.info(f"Generated report {report.id} successfully")
            
        except Exception as e:
            logger.error(f"Error generating report {report.id}: {e}")
            report.status = ReportStatus.FAILED
            report.generation_error = str(e)
            db.commit()
    
    async def _generate_pdf_report(
        self,
        report: Report,
        scan: Scan,
        findings: List[Finding],
        options: Dict[str, Any]
    ) -> str:
        """Generate PDF report"""
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
            
            # Create PDF file
            file_path = os.path.join(self.reports_dir, f"report_{report.id}.pdf")
            doc = SimpleDocTemplate(file_path, pagesize=letter)
            
            # Get styles
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                alignment=1
            )
            
            # Build content
            content = []
            
            # Title
            content.append(Paragraph("Orange Sage Security Assessment Report", title_style))
            content.append(Spacer(1, 20))
            
            # Executive Summary
            content.append(Paragraph("Executive Summary", styles['Heading2']))
            content.append(Paragraph(f"Target: {scan.target.value if scan.target else 'N/A'}", styles['Normal']))
            content.append(Paragraph(f"Scan Date: {scan.created_at.strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            content.append(Paragraph(f"Total Findings: {len(findings)}", styles['Normal']))
            content.append(Spacer(1, 20))
            
            # Findings Summary Table
            if findings:
                content.append(Paragraph("Findings Summary", styles['Heading2']))
                
                # Count findings by severity
                severity_counts = {}
                for finding in findings:
                    severity = finding.severity.value
                    severity_counts[severity] = severity_counts.get(severity, 0) + 1
                
                # Create summary table
                summary_data = [["Severity", "Count"]]
                for severity in ["critical", "high", "medium", "low", "info"]:
                    count = severity_counts.get(severity, 0)
                    summary_data.append([severity.title(), str(count)])
                
                summary_table = Table(summary_data)
                summary_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 14),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                
                content.append(summary_table)
                content.append(Spacer(1, 20))
            
            # Detailed Findings
            if findings:
                content.append(Paragraph("Detailed Findings", styles['Heading2']))
                
                for i, finding in enumerate(findings, 1):
                    content.append(Paragraph(f"{i}. {finding.title}", styles['Heading3']))
                    content.append(Paragraph(f"Severity: {finding.severity.value.title()}", styles['Normal']))
                    content.append(Paragraph(f"Type: {finding.vulnerability_type or 'N/A'}", styles['Normal']))
                    content.append(Paragraph(f"Endpoint: {finding.endpoint or 'N/A'}", styles['Normal']))
                    content.append(Paragraph(f"Description: {finding.description}", styles['Normal']))
                    
                    if finding.remediation_text:
                        content.append(Paragraph(f"Remediation: {finding.remediation_text}", styles['Normal']))
                    
                    content.append(Spacer(1, 10))
            
            # Build PDF
            doc.build(content)
            
            return file_path
            
        except Exception as e:
            logger.error(f"Error generating PDF report: {e}")
            raise
    
    async def _generate_docx_report(
        self,
        report: Report,
        scan: Scan,
        findings: List[Finding],
        options: Dict[str, Any]
    ) -> str:
        """Generate DOCX report"""
        try:
            from docx import Document
            from docx.shared import Inches
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            # Create document
            doc = Document()
            
            # Title
            title = doc.add_heading('Orange Sage Security Assessment Report', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Executive Summary
            doc.add_heading('Executive Summary', level=1)
            doc.add_paragraph(f'Target: {scan.target.value if scan.target else "N/A"}')
            doc.add_paragraph(f'Scan Date: {scan.created_at.strftime("%Y-%m-%d %H:%M:%S")}')
            doc.add_paragraph(f'Total Findings: {len(findings)}')
            
            # Findings Summary
            if findings:
                doc.add_heading('Findings Summary', level=1)
                
                # Count findings by severity
                severity_counts = {}
                for finding in findings:
                    severity = finding.severity.value
                    severity_counts[severity] = severity_counts.get(severity, 0) + 1
                
                # Create summary table
                table = doc.add_table(rows=1, cols=2)
                table.style = 'Table Grid'
                hdr_cells = table.rows[0].cells
                hdr_cells[0].text = 'Severity'
                hdr_cells[1].text = 'Count'
                
                for severity in ["critical", "high", "medium", "low", "info"]:
                    count = severity_counts.get(severity, 0)
                    row_cells = table.add_row().cells
                    row_cells[0].text = severity.title()
                    row_cells[1].text = str(count)
            
            # Detailed Findings
            if findings:
                doc.add_heading('Detailed Findings', level=1)
                
                for i, finding in enumerate(findings, 1):
                    doc.add_heading(f'{i}. {finding.title}', level=2)
                    doc.add_paragraph(f'Severity: {finding.severity.value.title()}')
                    doc.add_paragraph(f'Type: {finding.vulnerability_type or "N/A"}')
                    doc.add_paragraph(f'Endpoint: {finding.endpoint or "N/A"}')
                    doc.add_paragraph(f'Description: {finding.description}')
                    
                    if finding.remediation_text:
                        doc.add_paragraph(f'Remediation: {finding.remediation_text}')
            
            # Save document
            file_path = os.path.join(self.reports_dir, f"report_{report.id}.docx")
            doc.save(file_path)
            
            return file_path
            
        except Exception as e:
            logger.error(f"Error generating DOCX report: {e}")
            raise
    
    async def _generate_html_report(
        self,
        report: Report,
        scan: Scan,
        findings: List[Finding],
        options: Dict[str, Any]
    ) -> str:
        """Generate HTML report"""
        try:
            # Create HTML content
            html_content = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>Orange Sage Security Assessment Report</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 40px; }}
                    .header {{ text-align: center; margin-bottom: 40px; }}
                    .summary {{ background-color: #f5f5f5; padding: 20px; margin: 20px 0; }}
                    .finding {{ border: 1px solid #ddd; margin: 20px 0; padding: 20px; }}
                    .critical {{ border-left: 5px solid #dc3545; }}
                    .high {{ border-left: 5px solid #fd7e14; }}
                    .medium {{ border-left: 5px solid #ffc107; }}
                    .low {{ border-left: 5px solid #28a745; }}
                    .info {{ border-left: 5px solid #17a2b8; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Orange Sage Security Assessment Report</h1>
                </div>
                
                <div class="summary">
                    <h2>Executive Summary</h2>
                    <p><strong>Target:</strong> {scan.target.value if scan.target else 'N/A'}</p>
                    <p><strong>Scan Date:</strong> {scan.created_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
                    <p><strong>Total Findings:</strong> {len(findings)}</p>
                </div>
                
                <h2>Findings Summary</h2>
                <table border="1" style="border-collapse: collapse; width: 100%;">
                    <tr>
                        <th>Severity</th>
                        <th>Count</th>
                    </tr>
            """
            
            # Count findings by severity
            severity_counts = {}
            for finding in findings:
                severity = finding.severity.value
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            for severity in ["critical", "high", "medium", "low", "info"]:
                count = severity_counts.get(severity, 0)
                html_content += f"<tr><td>{severity.title()}</td><td>{count}</td></tr>"
            
            html_content += """
                </table>
                
                <h2>Detailed Findings</h2>
            """
            
            # Add detailed findings
            for i, finding in enumerate(findings, 1):
                severity_class = finding.severity.value
                html_content += f"""
                <div class="finding {severity_class}">
                    <h3>{i}. {finding.title}</h3>
                    <p><strong>Severity:</strong> {finding.severity.value.title()}</p>
                    <p><strong>Type:</strong> {finding.vulnerability_type or 'N/A'}</p>
                    <p><strong>Endpoint:</strong> {finding.endpoint or 'N/A'}</p>
                    <p><strong>Description:</strong> {finding.description}</p>
                """
                
                if finding.remediation_text:
                    html_content += f"<p><strong>Remediation:</strong> {finding.remediation_text}</p>"
                
                html_content += "</div>"
            
            html_content += """
            </body>
            </html>
            """
            
            # Save HTML file
            file_path = os.path.join(self.reports_dir, f"report_{report.id}.html")
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            return file_path
            
        except Exception as e:
            logger.error(f"Error generating HTML report: {e}")
            raise
    
    async def get_report_status(self, report_id: int, db: Session) -> Dict[str, Any]:
        """Get report generation status"""
        report = db.query(Report).filter(Report.id == report_id).first()
        if not report:
            return {"error": "Report not found"}
        
        return {
            "report_id": report_id,
            "status": report.status.value,
            "format": report.format.value,
            "name": report.name,
            "file_size": report.file_size,
            "download_url": report.download_url,
            "expires_at": report.expires_at.isoformat() if report.expires_at else None,
            "generated_at": report.generated_at.isoformat() if report.generated_at else None,
            "error": report.generation_error
        }
    
    async def download_report(self, report_id: int, db: Session) -> Optional[str]:
        """Get report download path"""
        report = db.query(Report).filter(Report.id == report_id).first()
        if not report or report.status != ReportStatus.COMPLETED:
            return None
        
        return report.storage_key


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\services\sandbox_service.py
"""
Sandbox Service for Orange Sage
Handles Docker container management for agent execution
"""

import asyncio
import logging
import docker
from datetime import datetime
from typing import Dict, List, Any, Optional
from app.core.config import settings

logger = logging.getLogger(__name__)


class SandboxService:
    """Service for managing Docker sandboxes"""
    
    def __init__(self):
        self.docker_client = None
        self.active_sandboxes: Dict[str, Dict[str, Any]] = {}
        self._initialize_docker()
    
    def _initialize_docker(self):
        """Initialize Docker client"""
        try:
            self.docker_client = docker.from_env()
            # Test connection
            self.docker_client.ping()
            logger.info("‚úÖ Docker client initialized successfully")
        except Exception as e:
            logger.info("‚ÑπÔ∏è  Docker not available - using mock sandbox mode (this is OK for local development)")
            logger.debug(f"Docker error details: {e}")
            self.docker_client = None
    
    async def create_sandbox(self, agent_id: str) -> Dict[str, Any]:
        """Create a new sandbox for agent execution"""
        if not self.docker_client:
            logger.warning("Docker not available - using mock sandbox for local development")
            return {
                "sandbox_id": f"mock_sandbox_{agent_id}",
                "status": "running",
                "container_id": None,
                "created_at": datetime.utcnow()
            }
        
        try:
            # Create Docker container
            container = self.docker_client.containers.run(
                image=settings.SANDBOX_IMAGE,
                name=f"orange_sage_sandbox_{agent_id}",
                detach=True,
                network=settings.DOCKER_NETWORK,
                mem_limit=settings.SANDBOX_MEMORY_LIMIT,
                cpu_quota=int(float(settings.SANDBOX_CPU_LIMIT) * 100000),
                environment={
                    "AGENT_ID": agent_id,
                    "SANDBOX_MODE": "true"
                },
                volumes={
                    "/tmp/orange_sage_uploads": {"bind": "/workspace", "mode": "rw"}
                },
                working_dir="/workspace",
                remove=False
            )
            
            # Wait for container to be ready
            await asyncio.sleep(2)
            
            # Get container info
            container.reload()
            
            sandbox_info = {
                "workspace_id": container.id,
                "container_id": container.id,
                "container_name": container.name,
                "api_url": f"http://{container.name}:8000",
                "auth_token": f"token_{agent_id}",
                "agent_id": agent_id,
                "status": "running"
            }
            
            # Store sandbox info
            self.active_sandboxes[agent_id] = sandbox_info
            
            logger.info(f"Created sandbox for agent {agent_id}: {container.id}")
            
            return sandbox_info
            
        except Exception as e:
            logger.error(f"Error creating sandbox for agent {agent_id}: {e}")
            raise
    
    async def destroy_sandbox(self, agent_id: str) -> bool:
        """Destroy a sandbox"""
        try:
            if agent_id not in self.active_sandboxes:
                logger.warning(f"Sandbox for agent {agent_id} not found")
                return False
            
            sandbox_info = self.active_sandboxes[agent_id]
            container_id = sandbox_info["container_id"]
            
            # Get container
            try:
                container = self.docker_client.containers.get(container_id)
                
                # Stop and remove container
                container.stop(timeout=10)
                container.remove(force=True)
                
                logger.info(f"Destroyed sandbox for agent {agent_id}: {container_id}")
                
            except docker.errors.NotFound:
                logger.warning(f"Container {container_id} not found")
            except Exception as e:
                logger.error(f"Error destroying container {container_id}: {e}")
            
            # Remove from active sandboxes
            del self.active_sandboxes[agent_id]
            
            return True
            
        except Exception as e:
            logger.error(f"Error destroying sandbox for agent {agent_id}: {e}")
            return False
    
    async def get_sandbox_status(self, agent_id: str) -> Optional[Dict[str, Any]]:
        """Get sandbox status"""
        if agent_id not in self.active_sandboxes:
            return None
        
        sandbox_info = self.active_sandboxes[agent_id]
        container_id = sandbox_info["container_id"]
        
        try:
            container = self.docker_client.containers.get(container_id)
            container.reload()
            
            return {
                "agent_id": agent_id,
                "container_id": container_id,
                "status": container.status,
                "created_at": container.attrs["Created"],
                "state": container.attrs["State"]
            }
            
        except docker.errors.NotFound:
            return None
        except Exception as e:
            logger.error(f"Error getting sandbox status for agent {agent_id}: {e}")
            return None
    
    async def execute_command(self, agent_id: str, command: str) -> Dict[str, Any]:
        """Execute command in sandbox"""
        try:
            if agent_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox for agent {agent_id} not found")
            
            sandbox_info = self.active_sandboxes[agent_id]
            container_id = sandbox_info["container_id"]
            
            container = self.docker_client.containers.get(container_id)
            
            # Execute command
            result = container.exec_run(
                command,
                workdir="/workspace",
                environment={"AGENT_ID": agent_id}
            )
            
            return {
                "exit_code": result.exit_code,
                "stdout": result.output.decode("utf-8") if result.output else "",
                "stderr": "",
                "success": result.exit_code == 0
            }
            
        except Exception as e:
            logger.error(f"Error executing command in sandbox {agent_id}: {e}")
            return {
                "exit_code": -1,
                "stdout": "",
                "stderr": str(e),
                "success": False
            }
    
    async def upload_file(self, agent_id: str, file_path: str, content: bytes) -> bool:
        """Upload file to sandbox"""
        try:
            if agent_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox for agent {agent_id} not found")
            
            sandbox_info = self.active_sandboxes[agent_id]
            container_id = sandbox_info["container_id"]
            
            container = self.docker_client.containers.get(container_id)
            
            # Create file in container
            import io
            file_obj = io.BytesIO(content)
            
            # Use put_archive to upload file
            container.put_archive("/workspace", file_obj.getvalue())
            
            logger.info(f"Uploaded file {file_path} to sandbox {agent_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error uploading file to sandbox {agent_id}: {e}")
            return False
    
    async def download_file(self, agent_id: str, file_path: str) -> Optional[bytes]:
        """Download file from sandbox"""
        try:
            if agent_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox for agent {agent_id} not found")
            
            sandbox_info = self.active_sandboxes[agent_id]
            container_id = sandbox_info["container_id"]
            
            container = self.docker_client.containers.get(container_id)
            
            # Get file from container
            stream, stat = container.get_archive(f"/workspace/{file_path}")
            
            # Read the stream
            import tarfile
            import io
            
            file_obj = io.BytesIO()
            for chunk in stream:
                file_obj.write(chunk)
            
            file_obj.seek(0)
            
            # Extract file from tar
            with tarfile.open(fileobj=file_obj, mode='r') as tar:
                for member in tar.getmembers():
                    if member.name.endswith(file_path):
                        return tar.extractfile(member).read()
            
            return None
            
        except Exception as e:
            logger.error(f"Error downloading file from sandbox {agent_id}: {e}")
            return None
    
    async def cleanup_all(self):
        """Cleanup all active sandboxes"""
        try:
            for agent_id in list(self.active_sandboxes.keys()):
                await self.destroy_sandbox(agent_id)
            
            logger.info("Cleaned up all sandboxes")
            
        except Exception as e:
            logger.error(f"Error during sandbox cleanup: {e}")
    
    def get_active_sandboxes(self) -> List[Dict[str, Any]]:
        """Get list of active sandboxes"""
        return list(self.active_sandboxes.values())


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\utils\agent_factory.py
"""
Agent Factory for Orange Sage
Creates and manages different types of AI agents
"""

import logging
from typing import Dict, Any, Type, List
from app.services.llm_service import LLMService
from app.services.sandbox_service import SandboxService

logger = logging.getLogger(__name__)


class BaseAgent:
    """Base agent class"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.agent_id = config.get("agent_id")
        self.task = config.get("task")
        self.sandbox_info = config.get("sandbox_info")
        self.llm_config = config.get("llm_config", {})
        
        # Initialize services
        self.llm_service = LLMService()
        self.sandbox_service = SandboxService()
    
    async def execute(self) -> Dict[str, Any]:
        """Execute the agent's task"""
        raise NotImplementedError
    
    async def cancel(self):
        """Cancel agent execution"""
        pass


class OrangeSageAgent(BaseAgent):
    """Orange Sage security assessment agent"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.prompt_modules = config.get("prompt_modules", ["root_agent"])
    
    async def execute(self) -> Dict[str, Any]:
        """Execute security assessment"""
        try:
            # Initialize assessment
            assessment_result = await self._initialize_assessment()
            
            # Perform reconnaissance
            recon_result = await self._perform_reconnaissance()
            
            # Perform vulnerability testing
            vuln_result = await self._perform_vulnerability_testing()
            
            # Generate findings
            findings = await self._generate_findings(assessment_result, recon_result, vuln_result)
            
            return {
                "success": True,
                "findings": findings,
                "assessment_summary": {
                    "total_findings": len(findings),
                    "critical_count": len([f for f in findings if f.get("severity") == "critical"]),
                    "high_count": len([f for f in findings if f.get("severity") == "high"]),
                    "medium_count": len([f for f in findings if f.get("severity") == "medium"]),
                    "low_count": len([f for f in findings if f.get("severity") == "low"])
                }
            }
            
        except Exception as e:
            logger.error(f"Error in OrangeSageAgent execution: {e}")
            return {
                "success": False,
                "error": str(e),
                "findings": []
            }
    
    async def _initialize_assessment(self) -> Dict[str, Any]:
        """Initialize security assessment"""
        # This would contain the actual Orange Sage logic
        # For now, return a basic structure
        return {
            "target": self.task,
            "assessment_type": "comprehensive",
            "started_at": "2024-01-01T00:00:00Z"
        }
    
    async def _perform_reconnaissance(self) -> Dict[str, Any]:
        """Perform reconnaissance phase"""
        # This would contain actual recon logic
        return {
            "endpoints_discovered": 5,
            "technologies_identified": ["Apache", "PHP", "MySQL"],
            "subdomains_found": 2
        }
    
    async def _perform_vulnerability_testing(self) -> Dict[str, Any]:
        """Perform vulnerability testing"""
        # This would contain actual vulnerability testing logic
        return {
            "tests_performed": 10,
            "vulnerabilities_found": 3,
            "false_positives": 1
        }
    
    async def _generate_findings(self, assessment: Dict, recon: Dict, vuln: Dict) -> List[Dict[str, Any]]:
        """Generate security findings"""
        # This would contain actual finding generation logic
        # For now, return sample findings
        return [
            {
                "title": "SQL Injection Vulnerability",
                "description": "The application is vulnerable to SQL injection attacks",
                "severity": "high",
                "type": "sql_injection",
                "endpoint": "/login",
                "parameter": "username",
                "method": "POST",
                "remediation": "Use parameterized queries to prevent SQL injection",
                "references": {
                    "CWE": "CWE-89",
                    "OWASP": "A03:2021 ‚Äì Injection"
                }
            },
            {
                "title": "Cross-Site Scripting (XSS)",
                "description": "Reflected XSS vulnerability found in search parameter",
                "severity": "medium",
                "type": "xss",
                "endpoint": "/search",
                "parameter": "q",
                "method": "GET",
                "remediation": "Implement proper input validation and output encoding",
                "references": {
                    "CWE": "CWE-79",
                    "OWASP": "A03:2021 ‚Äì Injection"
                }
            }
        ]


class ReconnaissanceAgent(BaseAgent):
    """Reconnaissance agent for information gathering"""
    
    async def execute(self) -> Dict[str, Any]:
        """Execute reconnaissance tasks"""
        try:
            # Perform reconnaissance tasks
            result = await self._perform_reconnaissance()
            
            return {
                "success": True,
                "reconnaissance_data": result
            }
            
        except Exception as e:
            logger.error(f"Error in ReconnaissanceAgent execution: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _perform_reconnaissance(self) -> Dict[str, Any]:
        """Perform reconnaissance tasks"""
        # This would contain actual reconnaissance logic
        return {
            "subdomains": ["www.example.com", "api.example.com"],
            "ports": [80, 443, 8080],
            "technologies": ["Apache", "PHP", "MySQL"],
            "endpoints": ["/", "/login", "/api", "/admin"]
        }


class VulnerabilityAgent(BaseAgent):
    """Vulnerability testing agent"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.vulnerability_type = config.get("vulnerability_type", "general")
    
    async def execute(self) -> Dict[str, Any]:
        """Execute vulnerability testing"""
        try:
            # Perform vulnerability testing
            result = await self._perform_vulnerability_testing()
            
            return {
                "success": True,
                "vulnerability_data": result
            }
            
        except Exception as e:
            logger.error(f"Error in VulnerabilityAgent execution: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _perform_vulnerability_testing(self) -> Dict[str, Any]:
        """Perform vulnerability testing"""
        # This would contain actual vulnerability testing logic
        return {
            "tests_performed": 5,
            "vulnerabilities_found": 2,
            "test_results": [
                {"test": "SQL Injection", "result": "vulnerable"},
                {"test": "XSS", "result": "vulnerable"},
                {"test": "CSRF", "result": "not_vulnerable"}
            ]
        }


class AgentFactory:
    """Factory for creating agents"""
    
    def __init__(self):
        self.agent_types = {
            "OrangeSageAgent": OrangeSageAgent,
            "ReconnaissanceAgent": ReconnaissanceAgent,
            "VulnerabilityAgent": VulnerabilityAgent
        }
    
    def create_agent(self, agent_type: str, config: Dict[str, Any]) -> BaseAgent:
        """Create an agent of the specified type"""
        if agent_type not in self.agent_types:
            raise ValueError(f"Unknown agent type: {agent_type}")
        
        agent_class = self.agent_types[agent_type]
        return agent_class(config)
    
    def get_available_agent_types(self) -> List[str]:
        """Get list of available agent types"""
        return list(self.agent_types.keys())
    
    def register_agent_type(self, name: str, agent_class: Type[BaseAgent]):
        """Register a new agent type"""
        self.agent_types[name] = agent_class


# File: C:\Users\user\Desktop\Orange-Sage\backend\app\utils\auth.py
"""
Authentication utilities
"""

from datetime import datetime, timedelta
from typing import Optional
import jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.database import get_db
from app.models.user import User

# Password hashing - using argon2 instead of bcrypt to avoid 72-byte limitation
pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/v1/auth/login")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """Create an access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:
    """Get current user from token"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except jwt.PyJWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception
    
    return user


# File: C:\Users\user\Desktop\Orange-Sage\frontend\next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  output: 'standalone',
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
  },
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Credentials', value: 'true' },
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,DELETE,PATCH,POST,PUT' },
          { key: 'Access-Control-Allow-Headers', value: 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization' },
        ],
      },
    ];
  },
}

module.exports = nextConfig



# File: C:\Users\user\Desktop\Orange-Sage\frontend\README.md
# sage-frontend
